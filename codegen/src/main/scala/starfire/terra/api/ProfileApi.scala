/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.BillingAccount
import starfire.terra.model.BillingAccountRedirect
import starfire.terra.model.BillingProjectMembership
import starfire.terra.model.BillingProjectStatus
import starfire.terra.model.CuratorStatus
import starfire.terra.model.ErrorReport
import starfire.terra.model.Me
import starfire.terra.model.Profile
import starfire.terra.model.RawlsMe
import starfire.terra.model.RegisterProfile
import starfire.terra.model.TerraPreference
import starfire.terra.model.UserImportPermission
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class ProfileApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new ProfileApiAsyncHelper(client, config)

  /**
   * List billing projects for a user
   * 
   *
   * @return List[BillingProjectMembership]
   */
  def billing(): Option[List[BillingProjectMembership]] = {
    val await = Try(Await.result(billingAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List billing projects for a user asynchronously
   * 
   *
   * @return Future(List[BillingProjectMembership])
   */
  def billingAsync(): Future[List[BillingProjectMembership]] = {
      helper.billing()
  }

  /**
   * List billing accounts for a user
   * 
   *
   * @return List[BillingAccount]
   */
  def billingAccounts(): Option[List[BillingAccount]] = {
    val await = Try(Await.result(billingAccountsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List billing accounts for a user asynchronously
   * 
   *
   * @return Future(List[BillingAccount])
   */
  def billingAccountsAsync(): Future[List[BillingAccount]] = {
      helper.billingAccounts()
  }

  /**
   * billing project status
   * billing project status
   *
   * @param projectName Name of the billing project 
   * @return BillingProjectStatus
   */
  def billingProjectStatus(projectName: String): Option[BillingProjectStatus] = {
    val await = Try(Await.result(billingProjectStatusAsync(projectName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * billing project status asynchronously
   * billing project status
   *
   * @param projectName Name of the billing project 
   * @return Future(BillingProjectStatus)
   */
  def billingProjectStatusAsync(projectName: String): Future[BillingProjectStatus] = {
      helper.billingProjectStatus(projectName)
  }

  /**
   * Returns a list of all keys and values stored in the user profile service for the currently logged-in user.
   * 
   *
   * @return RegisterProfile
   */
  def getAll(): Option[RegisterProfile] = {
    val await = Try(Await.result(getAllAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns a list of all keys and values stored in the user profile service for the currently logged-in user. asynchronously
   * 
   *
   * @return Future(RegisterProfile)
   */
  def getAllAsync(): Future[RegisterProfile] = {
      helper.getAll()
  }

  /**
   * Returns the proxy group email for the current user
   * 
   *
   * @param email User email whose proxy group to retrieve 
   * @return String
   */
  def getProxyGroup(email: String): Option[String] = {
    val await = Try(Await.result(getProxyGroupAsync(email), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns the proxy group email for the current user asynchronously
   * 
   *
   * @param email User email whose proxy group to retrieve 
   * @return Future(String)
   */
  def getProxyGroupAsync(email: String): Future[String] = {
      helper.getProxyGroup(email)
  }

  /**
   * Returns the current user&#39;s preference for Terra UI vs. Legacy view
   * 
   *
   * @return TerraPreference
   */
  def getTerraPreference(): Option[TerraPreference] = {
    val await = Try(Await.result(getTerraPreferenceAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns the current user&#39;s preference for Terra UI vs. Legacy view asynchronously
   * 
   *
   * @return Future(TerraPreference)
   */
  def getTerraPreferenceAsync(): Future[TerraPreference] = {
      helper.getTerraPreference()
  }

  /**
   * Passes through to the Rawls userinfo API and returns its response
   * 
   *
   * @return RawlsMe
   */
  def getUserStatus(): Option[RawlsMe] = {
    val await = Try(Await.result(getUserStatusAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Passes through to the Rawls userinfo API and returns its response asynchronously
   * 
   *
   * @return Future(RawlsMe)
   */
  def getUserStatusAsync(): Future[RawlsMe] = {
      helper.getUserStatus()
  }

  /**
   * Check the user&#39;s ability to import a method config into a workspace
   * 
   *
   * @return UserImportPermission
   */
  def importStatus(): Option[UserImportPermission] = {
    val await = Try(Await.result(importStatusAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Check the user&#39;s ability to import a method config into a workspace asynchronously
   * 
   *
   * @return Future(UserImportPermission)
   */
  def importStatusAsync(): Future[UserImportPermission] = {
      helper.importStatus()
  }

  /**
   * Query to see if you&#39;re a library curator
   * gets the curator status of a user
   *
   * @return CuratorStatus
   */
  def isCurator(): Option[CuratorStatus] = {
    val await = Try(Await.result(isCuratorAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Query to see if you&#39;re a library curator asynchronously
   * gets the curator status of a user
   *
   * @return Future(CuratorStatus)
   */
  def isCuratorAsync(): Future[CuratorStatus] = {
      helper.isCurator()
  }

  /**
   * Returns registration and activation status for the current user
   * 
   *
   * @return Me
   */
  def me(): Option[Me] = {
    val await = Try(Await.result(meAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Returns registration and activation status for the current user asynchronously
   * 
   *
   * @return Future(Me)
   */
  def meAsync(): Future[Me] = {
      helper.me()
  }

  /**
   * Set userAgreed flag to true
   * 
   *
   * @return void
   */
  def recordUserAgreement() = {
    val await = Try(Await.result(recordUserAgreementAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set userAgreed flag to true asynchronously
   * 
   *
   * @return Future(void)
   */
  def recordUserAgreementAsync() = {
      helper.recordUserAgreement()
  }

  /**
   * Sets the current user&#39;s preference to use Legacy view, not Terra UI
   * 
   *
   * @return TerraPreference
   */
  def setFCPreference(): Option[TerraPreference] = {
    val await = Try(Await.result(setFCPreferenceAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets the current user&#39;s preference to use Legacy view, not Terra UI asynchronously
   * 
   *
   * @return Future(TerraPreference)
   */
  def setFCPreferenceAsync(): Future[TerraPreference] = {
      helper.setFCPreference()
  }

  /**
   * Sets a profile object in the user profile service for the currently logged-in user.
   * 
   *
   * @param profile A complete profile (optional)
   * @return void
   */
  def setProfile(profile: Option[Profile] = None) = {
    val await = Try(Await.result(setProfileAsync(profile), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets a profile object in the user profile service for the currently logged-in user. asynchronously
   * 
   *
   * @param profile A complete profile (optional)
   * @return Future(void)
   */
  def setProfileAsync(profile: Option[Profile] = None) = {
      helper.setProfile(profile)
  }

  /**
   * Sets the current user&#39;s preference to use Terra UI, not Legacy view
   * 
   *
   * @return TerraPreference
   */
  def setTerraPreference(): Option[TerraPreference] = {
    val await = Try(Await.result(setTerraPreferenceAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sets the current user&#39;s preference to use Terra UI, not Legacy view asynchronously
   * 
   *
   * @return Future(TerraPreference)
   */
  def setTerraPreferenceAsync(): Future[TerraPreference] = {
      helper.setTerraPreference()
  }

  /**
   * Update the preferences for the user
   * 
   *
   * @param preferences The preferences to set as a Map[String, String] 
   * @return void
   */
  def updateProfile(preferences: Any) = {
    val await = Try(Await.result(updateProfileAsync(preferences), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update the preferences for the user asynchronously
   * 
   *
   * @param preferences The preferences to set as a Map[String, String] 
   * @return Future(void)
   */
  def updateProfileAsync(preferences: Any) = {
      helper.updateProfile(preferences)
  }

  /**
   * Passes through to Google&#39;s userinfo API and returns its response
   * See https://developers.google.com/+/web/api/rest/openidconnect/getOpenIdConnect for response info. Userinfo endpoint lives at https://www.googleapis.com/oauth2/v3/userinfo. 
   *
   * @return void
   */
  def userInfo() = {
    val await = Try(Await.result(userInfoAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Passes through to Google&#39;s userinfo API and returns its response asynchronously
   * See https://developers.google.com/+/web/api/rest/openidconnect/getOpenIdConnect for response info. Userinfo endpoint lives at https://www.googleapis.com/oauth2/v3/userinfo. 
   *
   * @return Future(void)
   */
  def userInfoAsync() = {
      helper.userInfo()
  }

  /**
   * Enroll or Finalize yourself in FireCloud free trial
   * * **Enroll:** starts an enabled user&#39;s trial and adds them to a billing project. * **Finalize:** concludes a terminated user&#39;s trial progress. 
   *
   * @param operation operation user can perform (optional, default to enroll)
   * @return void
   */
  def userTrial(operation: Option[String] = Option("enroll")) = {
    val await = Try(Await.result(userTrialAsync(operation), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Enroll or Finalize yourself in FireCloud free trial asynchronously
   * * **Enroll:** starts an enabled user&#39;s trial and adds them to a billing project. * **Finalize:** concludes a terminated user&#39;s trial progress. 
   *
   * @param operation operation user can perform (optional, default to enroll)
   * @return Future(void)
   */
  def userTrialAsync(operation: Option[String] = Option("enroll")) = {
      helper.userTrial(operation)
  }

}

class ProfileApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def billing()(implicit reader: ClientResponseReader[List[BillingProjectMembership]]): Future[List[BillingProjectMembership]] = {
    // create path and map variables
    val path = (addFmt("/api/profile/billing"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def billingAccounts()(implicit reader: ClientResponseReader[List[BillingAccount]]): Future[List[BillingAccount]] = {
    // create path and map variables
    val path = (addFmt("/api/profile/billingAccounts"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def billingProjectStatus(projectName: String)(implicit reader: ClientResponseReader[BillingProjectStatus]): Future[BillingProjectStatus] = {
    // create path and map variables
    val path = (addFmt("/api/profile/billing/{projectName}")
      replaceAll("\\{" + "projectName" + "\\}", projectName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (projectName == null) throw new Exception("Missing required parameter 'projectName' when calling ProfileApi->billingProjectStatus")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getAll()(implicit reader: ClientResponseReader[RegisterProfile]): Future[RegisterProfile] = {
    // create path and map variables
    val path = (addFmt("/register/profile"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getProxyGroup(email: String)(implicit reader: ClientResponseReader[String]): Future[String] = {
    // create path and map variables
    val path = (addFmt("/api/proxyGroup/{email}")
      replaceAll("\\{" + "email" + "\\}", email.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (email == null) throw new Exception("Missing required parameter 'email' when calling ProfileApi->getProxyGroup")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTerraPreference()(implicit reader: ClientResponseReader[TerraPreference]): Future[TerraPreference] = {
    // create path and map variables
    val path = (addFmt("/api/profile/terra"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getUserStatus()(implicit reader: ClientResponseReader[RawlsMe]): Future[RawlsMe] = {
    // create path and map variables
    val path = (addFmt("/register"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def importStatus()(implicit reader: ClientResponseReader[UserImportPermission]): Future[UserImportPermission] = {
    // create path and map variables
    val path = (addFmt("/api/profile/importstatus"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def isCurator()(implicit reader: ClientResponseReader[CuratorStatus]): Future[CuratorStatus] = {
    // create path and map variables
    val path = (addFmt("/api/library/user/role/curator"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def me()(implicit reader: ClientResponseReader[Me]): Future[Me] = {
    // create path and map variables
    val path = (addFmt("/me"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def recordUserAgreement()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/profile/trial/userAgreement"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setFCPreference()(implicit reader: ClientResponseReader[TerraPreference]): Future[TerraPreference] = {
    // create path and map variables
    val path = (addFmt("/api/profile/terra"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setProfile(profile: Option[Profile] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[Profile]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/register/profile"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(profile))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setTerraPreference()(implicit reader: ClientResponseReader[TerraPreference]): Future[TerraPreference] = {
    // create path and map variables
    val path = (addFmt("/api/profile/terra"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateProfile(preferences: Any)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Any]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/profile/preferences"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(preferences))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userInfo()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/register/userinfo"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def userTrial(operation: Option[String] = Option("enroll")
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/profile/trial"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    operation match {
      case Some(param) => queryParams += "operation" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
