/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.Body
import starfire.terra.model.ConfigurationQuery
import starfire.terra.model.ConfigurationResponse
import starfire.terra.model.ConfigurationResponseWithPayloadObject
import starfire.terra.model.CopyConfigurationIngest
import starfire.terra.model.Error
import starfire.terra.model.ErrorReport
import starfire.terra.model.MethodAclPair
import starfire.terra.model.MethodConfigACL
import starfire.terra.model.MethodDefinition
import starfire.terra.model.MethodID
import starfire.terra.model.MethodQuery
import starfire.terra.model.MethodResponse
import starfire.terra.model.Number
import starfire.terra.model.PublishConfigurationIngest
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class MethodRepositoryApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new MethodRepositoryApiAsyncHelper(client, config)

  /**
   * Redact a single configuration.
   * Redacts a configuration and all of its associated configurations 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @return Number
   */
  def apiConfigurationsNamespaceNameSnapshotIdDelete(namespace: String, name: String, snapshotId: String): Option[Number] = {
    val await = Try(Await.result(apiConfigurationsNamespaceNameSnapshotIdDeleteAsync(namespace, name, snapshotId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Redact a single configuration. asynchronously
   * Redacts a configuration and all of its associated configurations 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @return Future(Number)
   */
  def apiConfigurationsNamespaceNameSnapshotIdDeleteAsync(namespace: String, name: String, snapshotId: String): Future[Number] = {
      helper.apiConfigurationsNamespaceNameSnapshotIdDelete(namespace, name, snapshotId)
  }

  /**
   * Add a configuration.
   * Inserts a method configuration into the method repository and gives the owner full access permissions. Must supply a namespace, name, payload, and entityType. Cannot supply a snapshotId 
   *
   * @param body Agora Entity (optional)
   * @return ConfigurationResponse
   */
  def apiConfigurationsPost(body: Option[ConfigurationQuery] = None): Option[ConfigurationResponse] = {
    val await = Try(Await.result(apiConfigurationsPostAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a configuration. asynchronously
   * Inserts a method configuration into the method repository and gives the owner full access permissions. Must supply a namespace, name, payload, and entityType. Cannot supply a snapshotId 
   *
   * @param body Agora Entity (optional)
   * @return Future(ConfigurationResponse)
   */
  def apiConfigurationsPostAsync(body: Option[ConfigurationQuery] = None): Future[ConfigurationResponse] = {
      helper.apiConfigurationsPost(body)
  }

  /**
   * List method definitions
   * List method definitions - i.e. unique namespace/name pairs - with counts of snapshots and associated configurations 
   *
   * @return List[MethodDefinition]
   */
  def apiMethodsDefinitionsGet(): Option[List[MethodDefinition]] = {
    val await = Try(Await.result(apiMethodsDefinitionsGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List method definitions asynchronously
   * List method definitions - i.e. unique namespace/name pairs - with counts of snapshots and associated configurations 
   *
   * @return Future(List[MethodDefinition])
   */
  def apiMethodsDefinitionsGetAsync(): Future[List[MethodDefinition]] = {
      helper.apiMethodsDefinitionsGet()
  }

  /**
   * List configurations associated with a method
   * Given the namespace/name of a method, returns all configurations in the repository that reference that method 
   *
   * @param namespace Namespace of method. 
   * @param name Name of method. 
   * @return List[ConfigurationResponseWithPayloadObject]
   */
  def apiMethodsNamespaceNameConfigurationsGet(namespace: String, name: String): Option[List[ConfigurationResponseWithPayloadObject]] = {
    val await = Try(Await.result(apiMethodsNamespaceNameConfigurationsGetAsync(namespace, name), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List configurations associated with a method asynchronously
   * Given the namespace/name of a method, returns all configurations in the repository that reference that method 
   *
   * @param namespace Namespace of method. 
   * @param name Name of method. 
   * @return Future(List[ConfigurationResponseWithPayloadObject])
   */
  def apiMethodsNamespaceNameConfigurationsGetAsync(namespace: String, name: String): Future[List[ConfigurationResponseWithPayloadObject]] = {
      helper.apiMethodsNamespaceNameConfigurationsGet(namespace, name)
  }

  /**
   * List compatible configurations for this method snapshot
   * Returns all configurations that 1. have the exact same input and output arguments as the supplied method snapshot, and 2. reference any snapshot of this method. 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @return List[ConfigurationResponseWithPayloadObject]
   */
  def apiMethodsNamespaceNameSnapshotIdConfigurationsGet(namespace: String, name: String, snapshotId: String): Option[List[ConfigurationResponseWithPayloadObject]] = {
    val await = Try(Await.result(apiMethodsNamespaceNameSnapshotIdConfigurationsGetAsync(namespace, name, snapshotId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List compatible configurations for this method snapshot asynchronously
   * Returns all configurations that 1. have the exact same input and output arguments as the supplied method snapshot, and 2. reference any snapshot of this method. 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @return Future(List[ConfigurationResponseWithPayloadObject])
   */
  def apiMethodsNamespaceNameSnapshotIdConfigurationsGetAsync(namespace: String, name: String, snapshotId: String): Future[List[ConfigurationResponseWithPayloadObject]] = {
      helper.apiMethodsNamespaceNameSnapshotIdConfigurationsGet(namespace, name, snapshotId)
  }

  /**
   * Redact a single method.
   * Redacts a method and all of its associated configurations 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @return Number
   */
  def apiMethodsNamespaceNameSnapshotIdDelete(namespace: String, name: String, snapshotId: String): Option[Number] = {
    val await = Try(Await.result(apiMethodsNamespaceNameSnapshotIdDeleteAsync(namespace, name, snapshotId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Redact a single method. asynchronously
   * Redacts a method and all of its associated configurations 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @return Future(Number)
   */
  def apiMethodsNamespaceNameSnapshotIdDeleteAsync(namespace: String, name: String, snapshotId: String): Future[Number] = {
      helper.apiMethodsNamespaceNameSnapshotIdDelete(namespace, name, snapshotId)
  }

  /**
   * Find a single method.
   * Returns one method that matches the namespace, name, and snapshotId. 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @param onlyPayload Boolean to return only the payload of the method. (optional, default to false)
   * @return MethodResponse
   */
  def apiMethodsNamespaceNameSnapshotIdGet(namespace: String, name: String, snapshotId: String, onlyPayload: Option[Boolean] = Option(false)): Option[MethodResponse] = {
    val await = Try(Await.result(apiMethodsNamespaceNameSnapshotIdGetAsync(namespace, name, snapshotId, onlyPayload), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Find a single method. asynchronously
   * Returns one method that matches the namespace, name, and snapshotId. 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @param onlyPayload Boolean to return only the payload of the method. (optional, default to false)
   * @return Future(MethodResponse)
   */
  def apiMethodsNamespaceNameSnapshotIdGetAsync(namespace: String, name: String, snapshotId: String, onlyPayload: Option[Boolean] = Option(false)): Future[MethodResponse] = {
      helper.apiMethodsNamespaceNameSnapshotIdGet(namespace, name, snapshotId, onlyPayload)
  }

  /**
   * Create a new snapshot of an existing Method.
   * Inserts a new snapshot of the method into the method repository and copies access permissions from previous snapshot, optionally redacting the source snapshot. Documentation, synopsis, and payload are the only arguments considered for the new snapshot; everything else is copied from the source. 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @param redact Should the source method be redacted? (optional, default to false)
   * @param body Agora Entity (optional)
   * @return MethodResponse
   */
  def apiMethodsNamespaceNameSnapshotIdPost(namespace: String, name: String, snapshotId: String, redact: Option[Boolean] = Option(false), body: Option[Body] = None): Option[MethodResponse] = {
    val await = Try(Await.result(apiMethodsNamespaceNameSnapshotIdPostAsync(namespace, name, snapshotId, redact, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a new snapshot of an existing Method. asynchronously
   * Inserts a new snapshot of the method into the method repository and copies access permissions from previous snapshot, optionally redacting the source snapshot. Documentation, synopsis, and payload are the only arguments considered for the new snapshot; everything else is copied from the source. 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @param redact Should the source method be redacted? (optional, default to false)
   * @param body Agora Entity (optional)
   * @return Future(MethodResponse)
   */
  def apiMethodsNamespaceNameSnapshotIdPostAsync(namespace: String, name: String, snapshotId: String, redact: Option[Boolean] = Option(false), body: Option[Body] = None): Future[MethodResponse] = {
      helper.apiMethodsNamespaceNameSnapshotIdPost(namespace, name, snapshotId, redact, body)
  }

  /**
   * Add a Method.
   * Inserts a method into the method repository and gives the owner full access permissions. Must supply a namespace name, payload, and entityType. Cannot supply a snapshotId 
   *
   * @param body Agora Entity (optional)
   * @return MethodResponse
   */
  def apiMethodsPost(body: Option[MethodQuery] = None): Option[MethodResponse] = {
    val await = Try(Await.result(apiMethodsPostAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add a Method. asynchronously
   * Inserts a method into the method repository and gives the owner full access permissions. Must supply a namespace name, payload, and entityType. Cannot supply a snapshotId 
   *
   * @param body Agora Entity (optional)
   * @return Future(MethodResponse)
   */
  def apiMethodsPostAsync(body: Option[MethodQuery] = None): Future[MethodResponse] = {
      helper.apiMethodsPost(body)
  }

  /**
   * Copy a Method Repository Configuration into a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return void
   */
  def copyFromMethodRepo(workspaceNamespace: String, workspaceName: String, configToCopy: CopyConfigurationIngest) = {
    val await = Try(Await.result(copyFromMethodRepoAsync(workspaceNamespace, workspaceName, configToCopy), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Copy a Method Repository Configuration into a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return Future(void)
   */
  def copyFromMethodRepoAsync(workspaceNamespace: String, workspaceName: String, configToCopy: CopyConfigurationIngest) = {
      helper.copyFromMethodRepo(workspaceNamespace, workspaceName, configToCopy)
  }

  /**
   * Copy a Method Config in a workspace to the Method Repository
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return void
   */
  def copyToMethodRepo(workspaceNamespace: String, workspaceName: String, configToCopy: PublishConfigurationIngest) = {
    val await = Try(Await.result(copyToMethodRepoAsync(workspaceNamespace, workspaceName, configToCopy), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Copy a Method Config in a workspace to the Method Repository asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return Future(void)
   */
  def copyToMethodRepoAsync(workspaceNamespace: String, workspaceName: String, configToCopy: PublishConfigurationIngest) = {
      helper.copyToMethodRepo(workspaceNamespace, workspaceName, configToCopy)
  }

  /**
   * Create a Method Configuration template from a Method
   * 
   *
   * @param methodName name of Method to use for template 
   * @return void
   */
  def createMethodTemplate(methodName: MethodID) = {
    val await = Try(Await.result(createMethodTemplateAsync(methodName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a Method Configuration template from a Method asynchronously
   * 
   *
   * @param methodName name of Method to use for template 
   * @return Future(void)
   */
  def createMethodTemplateAsync(methodName: MethodID) = {
      helper.createMethodTemplate(methodName)
  }

  /**
   * get ACL permissions on a Method Repository configuration
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @return MethodConfigACL
   */
  def getConfigACL(namespace: String, name: String, snapshotId: String): Option[MethodConfigACL] = {
    val await = Try(Await.result(getConfigACLAsync(namespace, name, snapshotId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get ACL permissions on a Method Repository configuration asynchronously
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @return Future(MethodConfigACL)
   */
  def getConfigACLAsync(namespace: String, name: String, snapshotId: String): Future[MethodConfigACL] = {
      helper.getConfigACL(namespace, name, snapshotId)
  }

  /**
   * get ACL permissions on a Method Repository Configuration Namespace
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @return MethodConfigACL
   */
  def getConfigNamespaceACL(namespace: String): Option[MethodConfigACL] = {
    val await = Try(Await.result(getConfigNamespaceACLAsync(namespace), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get ACL permissions on a Method Repository Configuration Namespace asynchronously
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @return Future(MethodConfigACL)
   */
  def getConfigNamespaceACLAsync(namespace: String): Future[MethodConfigACL] = {
      helper.getConfigNamespaceACL(namespace)
  }

  /**
   * get ACL permissions on a Method Repository method
   * 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @return MethodConfigACL
   */
  def getMethodACL(namespace: String, name: String, snapshotId: String): Option[MethodConfigACL] = {
    val await = Try(Await.result(getMethodACLAsync(namespace, name, snapshotId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get ACL permissions on a Method Repository method asynchronously
   * 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @return Future(MethodConfigACL)
   */
  def getMethodACLAsync(namespace: String, name: String, snapshotId: String): Future[MethodConfigACL] = {
      helper.getMethodACL(namespace, name, snapshotId)
  }

  /**
   * Get information about a method&#39;s inputs and outputs
   * 
   *
   * @param methodName name of Method to look up 
   * @return void
   */
  def getMethodIO(methodName: MethodID) = {
    val await = Try(Await.result(getMethodIOAsync(methodName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get information about a method&#39;s inputs and outputs asynchronously
   * 
   *
   * @param methodName name of Method to look up 
   * @return Future(void)
   */
  def getMethodIOAsync(methodName: MethodID) = {
      helper.getMethodIO(methodName)
  }

  /**
   * get ACL permissions on a Method Repository Method Namespace
   * 
   *
   * @param namespace Method Namespace 
   * @return MethodConfigACL
   */
  def getMethodNamespaceACL(namespace: String): Option[MethodConfigACL] = {
    val await = Try(Await.result(getMethodNamespaceACLAsync(namespace), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get ACL permissions on a Method Repository Method Namespace asynchronously
   * 
   *
   * @param namespace Method Namespace 
   * @return Future(MethodConfigACL)
   */
  def getMethodNamespaceACLAsync(namespace: String): Future[MethodConfigACL] = {
      helper.getMethodNamespaceACL(namespace)
  }

  /**
   * Get a Method Repository configuration
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @param payloadAsObject Instead of returning a string under key payload, return a JSON object under key payloadObject (optional, default to false)
   * @return ConfigurationResponse
   */
  def getMethodRepositoryConfiguration(namespace: String, name: String, snapshotId: String, payloadAsObject: Option[Boolean] = Option(false)): Option[ConfigurationResponse] = {
    val await = Try(Await.result(getMethodRepositoryConfigurationAsync(namespace, name, snapshotId, payloadAsObject), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a Method Repository configuration asynchronously
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @param payloadAsObject Instead of returning a string under key payload, return a JSON object under key payloadObject (optional, default to false)
   * @return Future(ConfigurationResponse)
   */
  def getMethodRepositoryConfigurationAsync(namespace: String, name: String, snapshotId: String, payloadAsObject: Option[Boolean] = Option(false)): Future[ConfigurationResponse] = {
      helper.getMethodRepositoryConfiguration(namespace, name, snapshotId, payloadAsObject)
  }

  /**
   * List Method Repository configurations. 
   * The configurations endpoint returns all configurations the requester has permissions to read that fit the filter criteria. 
   *
   * @param namespace Namespace of configuration. (optional)
   * @param name Name of configuration. (optional)
   * @param snapshotId Snapshot ID of configuration. (optional)
   * @param snapshotComment Snapshot comment of AgoraEntity (optional)
   * @param synopsis Synopsis of configuration. (optional)
   * @param documentation Documentation of configuration. (optional)
   * @param owner Owner of configuration. (optional)
   * @param payload Payload of configuration in WDL. (optional)
   * @param entityType Type of configuration - Task or Workflow (optional)
   * @return List[ConfigurationResponse]
   */
  def listMethodRepositoryConfigurations(namespace: Option[String] = None, name: Option[String] = None, snapshotId: Option[Number] = None, snapshotComment: Option[String] = None, synopsis: Option[String] = None, documentation: Option[String] = None, owner: Option[String] = None, payload: Option[String] = None, entityType: Option[String] = None): Option[List[ConfigurationResponse]] = {
    val await = Try(Await.result(listMethodRepositoryConfigurationsAsync(namespace, name, snapshotId, snapshotComment, synopsis, documentation, owner, payload, entityType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List Method Repository configurations.  asynchronously
   * The configurations endpoint returns all configurations the requester has permissions to read that fit the filter criteria. 
   *
   * @param namespace Namespace of configuration. (optional)
   * @param name Name of configuration. (optional)
   * @param snapshotId Snapshot ID of configuration. (optional)
   * @param snapshotComment Snapshot comment of AgoraEntity (optional)
   * @param synopsis Synopsis of configuration. (optional)
   * @param documentation Documentation of configuration. (optional)
   * @param owner Owner of configuration. (optional)
   * @param payload Payload of configuration in WDL. (optional)
   * @param entityType Type of configuration - Task or Workflow (optional)
   * @return Future(List[ConfigurationResponse])
   */
  def listMethodRepositoryConfigurationsAsync(namespace: Option[String] = None, name: Option[String] = None, snapshotId: Option[Number] = None, snapshotComment: Option[String] = None, synopsis: Option[String] = None, documentation: Option[String] = None, owner: Option[String] = None, payload: Option[String] = None, entityType: Option[String] = None): Future[List[ConfigurationResponse]] = {
      helper.listMethodRepositoryConfigurations(namespace, name, snapshotId, snapshotComment, synopsis, documentation, owner, payload, entityType)
  }

  /**
   * Lists Method Repository methods. 
   * 
   *
   * @param namespace Namespace of method. (optional)
   * @param name Name of method. (optional)
   * @param snapshotId Snapshot ID of method. (optional)
   * @param snapshotComment Snapshot comment of AgoraEntity (optional)
   * @param synopsis Synopsis of method. (optional)
   * @param documentation Documentation of method. (optional)
   * @param owner Owner of method. (optional)
   * @param payload Payload of method in WDL. (optional)
   * @param entityType Type of Method - Task or Workflow (optional)
   * @return List[MethodResponse]
   */
  def listMethodRepositoryMethods(namespace: Option[String] = None, name: Option[String] = None, snapshotId: Option[Number] = None, snapshotComment: Option[String] = None, synopsis: Option[String] = None, documentation: Option[String] = None, owner: Option[String] = None, payload: Option[String] = None, entityType: Option[String] = None): Option[List[MethodResponse]] = {
    val await = Try(Await.result(listMethodRepositoryMethodsAsync(namespace, name, snapshotId, snapshotComment, synopsis, documentation, owner, payload, entityType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Lists Method Repository methods.  asynchronously
   * 
   *
   * @param namespace Namespace of method. (optional)
   * @param name Name of method. (optional)
   * @param snapshotId Snapshot ID of method. (optional)
   * @param snapshotComment Snapshot comment of AgoraEntity (optional)
   * @param synopsis Synopsis of method. (optional)
   * @param documentation Documentation of method. (optional)
   * @param owner Owner of method. (optional)
   * @param payload Payload of method in WDL. (optional)
   * @param entityType Type of Method - Task or Workflow (optional)
   * @return Future(List[MethodResponse])
   */
  def listMethodRepositoryMethodsAsync(namespace: Option[String] = None, name: Option[String] = None, snapshotId: Option[Number] = None, snapshotComment: Option[String] = None, synopsis: Option[String] = None, documentation: Option[String] = None, owner: Option[String] = None, payload: Option[String] = None, entityType: Option[String] = None): Future[List[MethodResponse]] = {
      helper.listMethodRepositoryMethods(namespace, name, snapshotId, snapshotComment, synopsis, documentation, owner, payload, entityType)
  }

  /**
   * set ACLs for multiple methods in one call
   * 
   *
   * @param methodacls method acls to upsert 
   * @return List[MethodAclPair]
   */
  def multiUpsertMethodsACL(methodacls: List[MethodAclPair]): Option[List[MethodAclPair]] = {
    val await = Try(Await.result(multiUpsertMethodsACLAsync(methodacls), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * set ACLs for multiple methods in one call asynchronously
   * 
   *
   * @param methodacls method acls to upsert 
   * @return Future(List[MethodAclPair])
   */
  def multiUpsertMethodsACLAsync(methodacls: List[MethodAclPair]): Future[List[MethodAclPair]] = {
      helper.multiUpsertMethodsACL(methodacls)
  }

  /**
   * set ACL permissions on a Method Repository configuration
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @param payload the ACLs to upsert 
   * @return MethodConfigACL
   */
  def setConfigACL(namespace: String, name: String, snapshotId: String, payload: MethodConfigACL): Option[MethodConfigACL] = {
    val await = Try(Await.result(setConfigACLAsync(namespace, name, snapshotId, payload), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * set ACL permissions on a Method Repository configuration asynchronously
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param name Method Configuration Name 
   * @param snapshotId Method Configuration snapshot ID 
   * @param payload the ACLs to upsert 
   * @return Future(MethodConfigACL)
   */
  def setConfigACLAsync(namespace: String, name: String, snapshotId: String, payload: MethodConfigACL): Future[MethodConfigACL] = {
      helper.setConfigACL(namespace, name, snapshotId, payload)
  }

  /**
   * set ACL permissions on a Method Repository Configuration Namespace
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param payload the ACLs to upsert 
   * @return List[MethodConfigACL]
   */
  def setConfigNamespaceACL(namespace: String, payload: MethodConfigACL): Option[List[MethodConfigACL]] = {
    val await = Try(Await.result(setConfigNamespaceACLAsync(namespace, payload), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * set ACL permissions on a Method Repository Configuration Namespace asynchronously
   * 
   *
   * @param namespace Method Configuration Namespace 
   * @param payload the ACLs to upsert 
   * @return Future(List[MethodConfigACL])
   */
  def setConfigNamespaceACLAsync(namespace: String, payload: MethodConfigACL): Future[List[MethodConfigACL]] = {
      helper.setConfigNamespaceACL(namespace, payload)
  }

  /**
   * set ACL permissions on a Method Repository method
   * 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @param payload the ACLs to upsert 
   * @return MethodConfigACL
   */
  def setMethodACL(namespace: String, name: String, snapshotId: String, payload: MethodConfigACL): Option[MethodConfigACL] = {
    val await = Try(Await.result(setMethodACLAsync(namespace, name, snapshotId, payload), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * set ACL permissions on a Method Repository method asynchronously
   * 
   *
   * @param namespace Method Namespace 
   * @param name Method Name 
   * @param snapshotId Method snapshot ID 
   * @param payload the ACLs to upsert 
   * @return Future(MethodConfigACL)
   */
  def setMethodACLAsync(namespace: String, name: String, snapshotId: String, payload: MethodConfigACL): Future[MethodConfigACL] = {
      helper.setMethodACL(namespace, name, snapshotId, payload)
  }

  /**
   * set ACL permissions on a Method Repository Method Namespace
   * 
   *
   * @param namespace Method Namespace 
   * @param payload the ACLs to upsert 
   * @return MethodConfigACL
   */
  def setMethodNamespaceACL(namespace: String, payload: MethodConfigACL): Option[MethodConfigACL] = {
    val await = Try(Await.result(setMethodNamespaceACLAsync(namespace, payload), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * set ACL permissions on a Method Repository Method Namespace asynchronously
   * 
   *
   * @param namespace Method Namespace 
   * @param payload the ACLs to upsert 
   * @return Future(MethodConfigACL)
   */
  def setMethodNamespaceACLAsync(namespace: String, payload: MethodConfigACL): Future[MethodConfigACL] = {
      helper.setMethodNamespaceACL(namespace, payload)
  }

}

class MethodRepositoryApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def apiConfigurationsNamespaceNameSnapshotIdDelete(namespace: String,
    name: String,
    snapshotId: String)(implicit reader: ClientResponseReader[Number]): Future[Number] = {
    // create path and map variables
    val path = (addFmt("/api/configurations/{namespace}/{name}/{snapshotId}")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->apiConfigurationsNamespaceNameSnapshotIdDelete")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->apiConfigurationsNamespaceNameSnapshotIdDelete")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->apiConfigurationsNamespaceNameSnapshotIdDelete")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiConfigurationsPost(body: Option[ConfigurationQuery] = None
    )(implicit reader: ClientResponseReader[ConfigurationResponse], writer: RequestWriter[Option[ConfigurationQuery]]): Future[ConfigurationResponse] = {
    // create path and map variables
    val path = (addFmt("/api/configurations"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsDefinitionsGet()(implicit reader: ClientResponseReader[List[MethodDefinition]]): Future[List[MethodDefinition]] = {
    // create path and map variables
    val path = (addFmt("/api/methods/definitions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsNamespaceNameConfigurationsGet(namespace: String,
    name: String)(implicit reader: ClientResponseReader[List[ConfigurationResponseWithPayloadObject]]): Future[List[ConfigurationResponseWithPayloadObject]] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/configurations")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->apiMethodsNamespaceNameConfigurationsGet")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->apiMethodsNamespaceNameConfigurationsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsNamespaceNameSnapshotIdConfigurationsGet(namespace: String,
    name: String,
    snapshotId: String)(implicit reader: ClientResponseReader[List[ConfigurationResponseWithPayloadObject]]): Future[List[ConfigurationResponseWithPayloadObject]] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/{snapshotId}/configurations")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdConfigurationsGet")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdConfigurationsGet")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdConfigurationsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsNamespaceNameSnapshotIdDelete(namespace: String,
    name: String,
    snapshotId: String)(implicit reader: ClientResponseReader[Number]): Future[Number] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/{snapshotId}")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdDelete")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdDelete")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdDelete")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsNamespaceNameSnapshotIdGet(namespace: String,
    name: String,
    snapshotId: String,
    onlyPayload: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[MethodResponse]): Future[MethodResponse] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/{snapshotId}")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdGet")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdGet")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdGet")

    onlyPayload match {
      case Some(param) => queryParams += "onlyPayload" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsNamespaceNameSnapshotIdPost(namespace: String,
    name: String,
    snapshotId: String,
    redact: Option[Boolean] = Option(false),
    body: Option[Body] = None
    )(implicit reader: ClientResponseReader[MethodResponse], writer: RequestWriter[Option[Body]]): Future[MethodResponse] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/{snapshotId}")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdPost")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdPost")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->apiMethodsNamespaceNameSnapshotIdPost")

    redact match {
      case Some(param) => queryParams += "redact" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def apiMethodsPost(body: Option[MethodQuery] = None
    )(implicit reader: ClientResponseReader[MethodResponse], writer: RequestWriter[Option[MethodQuery]]): Future[MethodResponse] = {
    // create path and map variables
    val path = (addFmt("/api/methods"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def copyFromMethodRepo(workspaceNamespace: String,
    workspaceName: String,
    configToCopy: CopyConfigurationIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[CopyConfigurationIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/copyFromMethodRepo")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodRepositoryApi->copyFromMethodRepo")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodRepositoryApi->copyFromMethodRepo")

    if (configToCopy == null) throw new Exception("Missing required parameter 'configToCopy' when calling MethodRepositoryApi->copyFromMethodRepo")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(configToCopy))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def copyToMethodRepo(workspaceNamespace: String,
    workspaceName: String,
    configToCopy: PublishConfigurationIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[PublishConfigurationIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/copyToMethodRepo")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodRepositoryApi->copyToMethodRepo")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodRepositoryApi->copyToMethodRepo")

    if (configToCopy == null) throw new Exception("Missing required parameter 'configToCopy' when calling MethodRepositoryApi->copyToMethodRepo")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(configToCopy))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createMethodTemplate(methodName: MethodID)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[MethodID]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/template"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (methodName == null) throw new Exception("Missing required parameter 'methodName' when calling MethodRepositoryApi->createMethodTemplate")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(methodName))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getConfigACL(namespace: String,
    name: String,
    snapshotId: String)(implicit reader: ClientResponseReader[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/configurations/{namespace}/{name}/{snapshotId}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->getConfigACL")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->getConfigACL")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->getConfigACL")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getConfigNamespaceACL(namespace: String)(implicit reader: ClientResponseReader[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/configurations/{namespace}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->getConfigNamespaceACL")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMethodACL(namespace: String,
    name: String,
    snapshotId: String)(implicit reader: ClientResponseReader[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/{snapshotId}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->getMethodACL")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->getMethodACL")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->getMethodACL")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMethodIO(methodName: MethodID)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[MethodID]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/inputsOutputs"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (methodName == null) throw new Exception("Missing required parameter 'methodName' when calling MethodRepositoryApi->getMethodIO")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(methodName))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMethodNamespaceACL(namespace: String)(implicit reader: ClientResponseReader[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->getMethodNamespaceACL")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getMethodRepositoryConfiguration(namespace: String,
    name: String,
    snapshotId: String,
    payloadAsObject: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[ConfigurationResponse]): Future[ConfigurationResponse] = {
    // create path and map variables
    val path = (addFmt("/api/configurations/{namespace}/{name}/{snapshotId}")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->getMethodRepositoryConfiguration")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->getMethodRepositoryConfiguration")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->getMethodRepositoryConfiguration")

    payloadAsObject match {
      case Some(param) => queryParams += "payloadAsObject" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listMethodRepositoryConfigurations(namespace: Option[String] = None,
    name: Option[String] = None,
    snapshotId: Option[Number] = None,
    snapshotComment: Option[String] = None,
    synopsis: Option[String] = None,
    documentation: Option[String] = None,
    owner: Option[String] = None,
    payload: Option[String] = None,
    entityType: Option[String] = None
    )(implicit reader: ClientResponseReader[List[ConfigurationResponse]]): Future[List[ConfigurationResponse]] = {
    // create path and map variables
    val path = (addFmt("/api/configurations"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    namespace match {
      case Some(param) => queryParams += "namespace" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    snapshotId match {
      case Some(param) => queryParams += "snapshotId" -> param.toString
      case _ => queryParams
    }
    snapshotComment match {
      case Some(param) => queryParams += "snapshotComment" -> param.toString
      case _ => queryParams
    }
    synopsis match {
      case Some(param) => queryParams += "synopsis" -> param.toString
      case _ => queryParams
    }
    documentation match {
      case Some(param) => queryParams += "documentation" -> param.toString
      case _ => queryParams
    }
    owner match {
      case Some(param) => queryParams += "owner" -> param.toString
      case _ => queryParams
    }
    payload match {
      case Some(param) => queryParams += "payload" -> param.toString
      case _ => queryParams
    }
    entityType match {
      case Some(param) => queryParams += "entityType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listMethodRepositoryMethods(namespace: Option[String] = None,
    name: Option[String] = None,
    snapshotId: Option[Number] = None,
    snapshotComment: Option[String] = None,
    synopsis: Option[String] = None,
    documentation: Option[String] = None,
    owner: Option[String] = None,
    payload: Option[String] = None,
    entityType: Option[String] = None
    )(implicit reader: ClientResponseReader[List[MethodResponse]]): Future[List[MethodResponse]] = {
    // create path and map variables
    val path = (addFmt("/api/methods"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    namespace match {
      case Some(param) => queryParams += "namespace" -> param.toString
      case _ => queryParams
    }
    name match {
      case Some(param) => queryParams += "name" -> param.toString
      case _ => queryParams
    }
    snapshotId match {
      case Some(param) => queryParams += "snapshotId" -> param.toString
      case _ => queryParams
    }
    snapshotComment match {
      case Some(param) => queryParams += "snapshotComment" -> param.toString
      case _ => queryParams
    }
    synopsis match {
      case Some(param) => queryParams += "synopsis" -> param.toString
      case _ => queryParams
    }
    documentation match {
      case Some(param) => queryParams += "documentation" -> param.toString
      case _ => queryParams
    }
    owner match {
      case Some(param) => queryParams += "owner" -> param.toString
      case _ => queryParams
    }
    payload match {
      case Some(param) => queryParams += "payload" -> param.toString
      case _ => queryParams
    }
    entityType match {
      case Some(param) => queryParams += "entityType" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def multiUpsertMethodsACL(methodacls: List[MethodAclPair])(implicit reader: ClientResponseReader[List[MethodAclPair]], writer: RequestWriter[List[MethodAclPair]]): Future[List[MethodAclPair]] = {
    // create path and map variables
    val path = (addFmt("/api/methods/permissions"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (methodacls == null) throw new Exception("Missing required parameter 'methodacls' when calling MethodRepositoryApi->multiUpsertMethodsACL")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(methodacls))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setConfigACL(namespace: String,
    name: String,
    snapshotId: String,
    payload: MethodConfigACL)(implicit reader: ClientResponseReader[MethodConfigACL], writer: RequestWriter[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/configurations/{namespace}/{name}/{snapshotId}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->setConfigACL")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->setConfigACL")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->setConfigACL")

    if (payload == null) throw new Exception("Missing required parameter 'payload' when calling MethodRepositoryApi->setConfigACL")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(payload))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setConfigNamespaceACL(namespace: String,
    payload: MethodConfigACL)(implicit reader: ClientResponseReader[List[MethodConfigACL]], writer: RequestWriter[MethodConfigACL]): Future[List[MethodConfigACL]] = {
    // create path and map variables
    val path = (addFmt("/api/configurations/{namespace}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->setConfigNamespaceACL")

    if (payload == null) throw new Exception("Missing required parameter 'payload' when calling MethodRepositoryApi->setConfigNamespaceACL")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(payload))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setMethodACL(namespace: String,
    name: String,
    snapshotId: String,
    payload: MethodConfigACL)(implicit reader: ClientResponseReader[MethodConfigACL], writer: RequestWriter[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/{name}/{snapshotId}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString)
      replaceAll("\\{" + "name" + "\\}", name.toString)
      replaceAll("\\{" + "snapshotId" + "\\}", snapshotId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->setMethodACL")

    if (name == null) throw new Exception("Missing required parameter 'name' when calling MethodRepositoryApi->setMethodACL")

    if (snapshotId == null) throw new Exception("Missing required parameter 'snapshotId' when calling MethodRepositoryApi->setMethodACL")

    if (payload == null) throw new Exception("Missing required parameter 'payload' when calling MethodRepositoryApi->setMethodACL")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(payload))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setMethodNamespaceACL(namespace: String,
    payload: MethodConfigACL)(implicit reader: ClientResponseReader[MethodConfigACL], writer: RequestWriter[MethodConfigACL]): Future[MethodConfigACL] = {
    // create path and map variables
    val path = (addFmt("/api/methods/{namespace}/permissions")
      replaceAll("\\{" + "namespace" + "\\}", namespace.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (namespace == null) throw new Exception("Missing required parameter 'namespace' when calling MethodRepositoryApi->setMethodNamespaceACL")

    if (payload == null) throw new Exception("Missing required parameter 'payload' when calling MethodRepositoryApi->setMethodNamespaceACL")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(payload))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
