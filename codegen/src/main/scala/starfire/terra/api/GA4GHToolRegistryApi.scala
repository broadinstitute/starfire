/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.Error
import starfire.terra.model.Metadata
import starfire.terra.model.Tool
import starfire.terra.model.ToolClass
import starfire.terra.model.ToolDescriptor
import starfire.terra.model.ToolVersion
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class GA4GHToolRegistryApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new GA4GHToolRegistryApiAsyncHelper(client, config)

  /**
   * Return some metadata that is useful for describing this registry
   * Return some metadata that is useful for describing this registry
   *
   * @return Metadata
   */
  def ga4ghV1MetadataGet(): Option[Metadata] = {
    val await = Try(Await.result(ga4ghV1MetadataGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Return some metadata that is useful for describing this registry asynchronously
   * Return some metadata that is useful for describing this registry
   *
   * @return Future(Metadata)
   */
  def ga4ghV1MetadataGetAsync(): Future[Metadata] = {
      helper.ga4ghV1MetadataGet()
  }

  /**
   * List all tool types
   * This endpoint returns all tool-classes available 
   *
   * @return List[ToolClass]
   */
  def ga4ghV1ToolClassesGet(): Option[List[ToolClass]] = {
    val await = Try(Await.result(ga4ghV1ToolClassesGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all tool types asynchronously
   * This endpoint returns all tool-classes available 
   *
   * @return Future(List[ToolClass])
   */
  def ga4ghV1ToolClassesGetAsync(): Future[List[ToolClass]] = {
      helper.ga4ghV1ToolClassesGet()
  }

  /**
   * List all tools
   * This endpoint returns all tools available. 
   *
   * @return List[Tool]
   */
  def ga4ghV1ToolsGet(): Option[List[Tool]] = {
    val await = Try(Await.result(ga4ghV1ToolsGetAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List all tools asynchronously
   * This endpoint returns all tools available. 
   *
   * @return Future(List[Tool])
   */
  def ga4ghV1ToolsGetAsync(): Future[List[Tool]] = {
      helper.ga4ghV1ToolsGet()
  }

  /**
   * List one specific tool, acts as an anchor for self references
   * This endpoint returns one specific tool (which has ToolVersions nested inside it)
   *
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60; 
   * @return Tool
   */
  def ga4ghV1ToolsIdGet(id: String): Option[Tool] = {
    val await = Try(Await.result(ga4ghV1ToolsIdGetAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List one specific tool, acts as an anchor for self references asynchronously
   * This endpoint returns one specific tool (which has ToolVersions nested inside it)
   *
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60; 
   * @return Future(Tool)
   */
  def ga4ghV1ToolsIdGetAsync(id: String): Future[Tool] = {
      helper.ga4ghV1ToolsIdGet(id)
  }

  /**
   * List versions of a tool
   * Returns all versions of the specified tool
   *
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60; 
   * @return List[ToolVersion]
   */
  def ga4ghV1ToolsIdVersionsGet(id: String): Option[List[ToolVersion]] = {
    val await = Try(Await.result(ga4ghV1ToolsIdVersionsGetAsync(id), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List versions of a tool asynchronously
   * Returns all versions of the specified tool
   *
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60; 
   * @return Future(List[ToolVersion])
   */
  def ga4ghV1ToolsIdVersionsGetAsync(id: String): Future[List[ToolVersion]] = {
      helper.ga4ghV1ToolsIdVersionsGet(id)
  }

  /**
   * List one specific tool version, acts as an anchor for self references
   * This endpoint returns one specific tool version
   *
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60; 
   * @param versionId An identifier of the tool version, scoped to this registry, for example &#x60;v1&#x60; 
   * @return ToolVersion
   */
  def ga4ghV1ToolsIdVersionsVersionIdGet(id: String, versionId: String): Option[ToolVersion] = {
    val await = Try(Await.result(ga4ghV1ToolsIdVersionsVersionIdGetAsync(id, versionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List one specific tool version, acts as an anchor for self references asynchronously
   * This endpoint returns one specific tool version
   *
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60; 
   * @param versionId An identifier of the tool version, scoped to this registry, for example &#x60;v1&#x60; 
   * @return Future(ToolVersion)
   */
  def ga4ghV1ToolsIdVersionsVersionIdGetAsync(id: String, versionId: String): Future[ToolVersion] = {
      helper.ga4ghV1ToolsIdVersionsVersionIdGet(id, versionId)
  }

  /**
   * Get the tool descriptor (WDL) for the specified tool.
   * Returns the WDL descriptor for the specified tool.
   *
   * @param `type` The output type of the descriptor. If not specified it is up to the underlying implementation to determine which output type to return. Plain types return the bare descriptor while the \&quot;non-plain\&quot; types return a descriptor wrapped with metadata.  
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;.    *In FireCloud, this must be a namespace + \&quot;:\&quot; + name. For instance, if your namespace   is &#39;foo&#39; and name is &#39;bar&#39;, this must be &#39;foo:bar&#39;.*  
   * @param versionId An identifier of the tool version for this particular tool registry, for example &#x60;v1&#x60;.    *In FireCloud, this must be an integer representing the FireCloud snapshot id.*  
   * @return ToolDescriptor
   */
  def ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGet(`type`: String, id: String, versionId: String): Option[ToolDescriptor] = {
    val await = Try(Await.result(ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGetAsync(`type`, id, versionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the tool descriptor (WDL) for the specified tool. asynchronously
   * Returns the WDL descriptor for the specified tool.
   *
   * @param `type` The output type of the descriptor. If not specified it is up to the underlying implementation to determine which output type to return. Plain types return the bare descriptor while the \&quot;non-plain\&quot; types return a descriptor wrapped with metadata.  
   * @param id A unique identifier of the tool, scoped to this registry, for example &#x60;123456&#x60;.    *In FireCloud, this must be a namespace + \&quot;:\&quot; + name. For instance, if your namespace   is &#39;foo&#39; and name is &#39;bar&#39;, this must be &#39;foo:bar&#39;.*  
   * @param versionId An identifier of the tool version for this particular tool registry, for example &#x60;v1&#x60;.    *In FireCloud, this must be an integer representing the FireCloud snapshot id.*  
   * @return Future(ToolDescriptor)
   */
  def ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGetAsync(`type`: String, id: String, versionId: String): Future[ToolDescriptor] = {
      helper.ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGet(`type`, id, versionId)
  }

}

class GA4GHToolRegistryApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def ga4ghV1MetadataGet()(implicit reader: ClientResponseReader[Metadata]): Future[Metadata] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/metadata"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def ga4ghV1ToolClassesGet()(implicit reader: ClientResponseReader[List[ToolClass]]): Future[List[ToolClass]] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/tool-classes"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def ga4ghV1ToolsGet()(implicit reader: ClientResponseReader[List[Tool]]): Future[List[Tool]] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/tools"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def ga4ghV1ToolsIdGet(id: String)(implicit reader: ClientResponseReader[Tool]): Future[Tool] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/tools/{id}")
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def ga4ghV1ToolsIdVersionsGet(id: String)(implicit reader: ClientResponseReader[List[ToolVersion]]): Future[List[ToolVersion]] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/tools/{id}/versions")
      replaceAll("\\{" + "id" + "\\}", id.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdVersionsGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def ga4ghV1ToolsIdVersionsVersionIdGet(id: String,
    versionId: String)(implicit reader: ClientResponseReader[ToolVersion]): Future[ToolVersion] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/tools/{id}/versions/{version-id}")
      replaceAll("\\{" + "id" + "\\}", id.toString)
      replaceAll("\\{" + "version-id" + "\\}", versionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdVersionsVersionIdGet")

    if (versionId == null) throw new Exception("Missing required parameter 'versionId' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdVersionsVersionIdGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGet(`type`: String,
    id: String,
    versionId: String)(implicit reader: ClientResponseReader[ToolDescriptor]): Future[ToolDescriptor] = {
    // create path and map variables
    val path = (addFmt("/ga4gh/v1/tools/{id}/versions/{version-id}/{type}/descriptor")
      replaceAll("\\{" + "type" + "\\}", `type`.toString)
      replaceAll("\\{" + "id" + "\\}", id.toString)
      replaceAll("\\{" + "version-id" + "\\}", versionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (`type` == null) throw new Exception("Missing required parameter '`type`' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGet")

    if (id == null) throw new Exception("Missing required parameter 'id' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGet")

    if (versionId == null) throw new Exception("Missing required parameter 'versionId' when calling GA4GHToolRegistryApi->ga4ghV1ToolsIdVersionsVersionIdTypeDescriptorGet")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
