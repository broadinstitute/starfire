/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.Consent
import starfire.terra.model.ErrorReport
import starfire.terra.model.LibraryBulkIndexResponse
import starfire.terra.model.LibraryMetadataInput
import starfire.terra.model.ResearchPurposeRequest
import starfire.terra.model.SearchTermRef
import starfire.terra.model.StringArray
import starfire.terra.model.StructuredDataRequest
import starfire.terra.model.Workspace
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class LibraryApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new LibraryApiAsyncHelper(client, config)

  /**
   * Data Use Search ingest
   * The ingest API will take the answers to consent questions and return the elasticsearch structure to persist with the data reference.
   *
   * @param body Structured Data Request 
   * @return void
   */
  def dataIngest(body: StructuredDataRequest) = {
    val await = Try(Await.result(dataIngestAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Data Use Search ingest asynchronously
   * The ingest API will take the answers to consent questions and return the elasticsearch structure to persist with the data reference.
   *
   * @param body Structured Data Request 
   * @return Future(void)
   */
  def dataIngestAsync(body: StructuredDataRequest) = {
      helper.dataIngest(body)
  }

  /**
   * Passes through to DUOS&#39; autocomplete method to select ontology terms of disease type that match the query term. 
   * 
   *
   * @param queryTerm The query term (word fragment) which the service should try and complete. 
   * @return void
   */
  def duosAutocomplete(queryTerm: String) = {
    val await = Try(Await.result(duosAutocompleteAsync(queryTerm), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Passes through to DUOS&#39; autocomplete method to select ontology terms of disease type that match the query term.  asynchronously
   * 
   *
   * @param queryTerm The query term (word fragment) which the service should try and complete. 
   * @return Future(void)
   */
  def duosAutocompleteAsync(queryTerm: String) = {
      helper.duosAutocomplete(queryTerm)
  }

  /**
   * Find Consent by ORSP ID
   * 
   *
   * @param orspId Finds the consent for the provided ORSP ID. 
   * @return Consent
   */
  def duosConsentOrspId(orspId: String): Option[Consent] = {
    val await = Try(Await.result(duosConsentOrspIdAsync(orspId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Find Consent by ORSP ID asynchronously
   * 
   *
   * @param orspId Finds the consent for the provided ORSP ID. 
   * @return Future(Consent)
   */
  def duosConsentOrspIdAsync(orspId: String): Future[Consent] = {
      helper.duosConsentOrspId(orspId)
  }

  /**
   * Generates an ElasticSearch clause for filtering by research purpose
   * 
   *
   * @param body Research Purpose Request 
   * @return void
   */
  def duosResearchPurposeQuery(body: ResearchPurposeRequest) = {
    val await = Try(Await.result(duosResearchPurposeQueryAsync(body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Generates an ElasticSearch clause for filtering by research purpose asynchronously
   * 
   *
   * @param body Research Purpose Request 
   * @return Future(void)
   */
  def duosResearchPurposeQueryAsync(body: ResearchPurposeRequest) = {
      helper.duosResearchPurposeQuery(body)
  }

  /**
   * searches published library datasets 
   * 
   *
   * @param searchParams Search terms and pagination parameters (optional)
   * @return void
   */
  def findDocuments(searchParams: Option[SearchTermRef] = None) = {
    val await = Try(Await.result(findDocumentsAsync(searchParams), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * searches published library datasets  asynchronously
   * 
   *
   * @param searchParams Search terms and pagination parameters (optional)
   * @return Future(void)
   */
  def findDocumentsAsync(searchParams: Option[SearchTermRef] = None) = {
      helper.findDocuments(searchParams)
  }

  /**
   * get the groups that can discover this library dataset 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return StringArray
   */
  def getDiscoverableGroups(workspaceNamespace: String, workspaceName: String): Option[StringArray] = {
    val await = Try(Await.result(getDiscoverableGroupsAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get the groups that can discover this library dataset  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(StringArray)
   */
  def getDiscoverableGroupsAsync(workspaceNamespace: String, workspaceName: String): Future[StringArray] = {
      helper.getDiscoverableGroups(workspaceNamespace, workspaceName)
  }

  /**
   * get the entire metadata for a library dataset 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return LibraryMetadataInput
   */
  def getLibraryMetadata(workspaceNamespace: String, workspaceName: String): Option[LibraryMetadataInput] = {
    val await = Try(Await.result(getLibraryMetadataAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get the entire metadata for a library dataset  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(LibraryMetadataInput)
   */
  def getLibraryMetadataAsync(workspaceNamespace: String, workspaceName: String): Future[LibraryMetadataInput] = {
      helper.getLibraryMetadata(workspaceNamespace, workspaceName)
  }

  /**
   * returns groups that can be used for discoverable datasets 
   * 
   *
   * @return List[String]
   */
  def groups(): Option[List[String]] = {
    val await = Try(Await.result(groupsAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * returns groups that can be used for discoverable datasets  asynchronously
   * 
   *
   * @return Future(List[String])
   */
  def groupsAsync(): Future[List[String]] = {
      helper.groups()
  }

  /**
   * suggestions for populating a field 
   * 
   *
   * @param field the property to get suggestions for 
   * @param q the initial text to complete 
   * @return void
   */
  def populateSuggest(field: String, q: String) = {
    val await = Try(Await.result(populateSuggestAsync(field, q), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * suggestions for populating a field  asynchronously
   * 
   *
   * @param field the property to get suggestions for 
   * @param q the initial text to complete 
   * @return Future(void)
   */
  def populateSuggestAsync(field: String, q: String) = {
      helper.populateSuggest(field, q)
  }

  /**
   * publish the workspace in the Library 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Workspace
   */
  def publishLibraryWorkspace(workspaceNamespace: String, workspaceName: String): Option[Workspace] = {
    val await = Try(Await.result(publishLibraryWorkspaceAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * publish the workspace in the Library  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(Workspace)
   */
  def publishLibraryWorkspaceAsync(workspaceNamespace: String, workspaceName: String): Future[Workspace] = {
      helper.publishLibraryWorkspace(workspaceNamespace, workspaceName)
  }

  /**
   * put the entire metadata for a library dataset 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param libraryMetadataJson Library metadata 
   * @param validate Should the payload be validated? Validation is always enabled for published datasets and defaults to false for unpublished datasets.  (optional)
   * @return Workspace
   */
  def putLibraryMetadata(workspaceNamespace: String, workspaceName: String, libraryMetadataJson: LibraryMetadataInput, validate: Option[Boolean] = None): Option[Workspace] = {
    val await = Try(Await.result(putLibraryMetadataAsync(workspaceNamespace, workspaceName, libraryMetadataJson, validate), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * put the entire metadata for a library dataset  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param libraryMetadataJson Library metadata 
   * @param validate Should the payload be validated? Validation is always enabled for published datasets and defaults to false for unpublished datasets.  (optional)
   * @return Future(Workspace)
   */
  def putLibraryMetadataAsync(workspaceNamespace: String, workspaceName: String, libraryMetadataJson: LibraryMetadataInput, validate: Option[Boolean] = None): Future[Workspace] = {
      helper.putLibraryMetadata(workspaceNamespace, workspaceName, libraryMetadataJson, validate)
  }

  /**
   * deletes and rebuilds the entire index of published library datasets 
   * 
   *
   * @return LibraryBulkIndexResponse
   */
  def reindexAll(): Option[LibraryBulkIndexResponse] = {
    val await = Try(Await.result(reindexAllAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * deletes and rebuilds the entire index of published library datasets  asynchronously
   * 
   *
   * @return Future(LibraryBulkIndexResponse)
   */
  def reindexAllAsync(): Future[LibraryBulkIndexResponse] = {
      helper.reindexAll()
  }

  /**
   * search suggestions 
   * 
   *
   * @param searchParams Search terms and pagination parameters (optional)
   * @return void
   */
  def searchSuggest(searchParams: Option[SearchTermRef] = None) = {
    val await = Try(Await.result(searchSuggestAsync(searchParams), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * search suggestions  asynchronously
   * 
   *
   * @param searchParams Search terms and pagination parameters (optional)
   * @return Future(void)
   */
  def searchSuggestAsync(searchParams: Option[SearchTermRef] = None) = {
      helper.searchSuggest(searchParams)
  }

  /**
   * unpublish the workspace in the Library 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Workspace
   */
  def unpublishLibraryWorkspace(workspaceNamespace: String, workspaceName: String): Option[Workspace] = {
    val await = Try(Await.result(unpublishLibraryWorkspaceAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * unpublish the workspace in the Library  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(Workspace)
   */
  def unpublishLibraryWorkspaceAsync(workspaceNamespace: String, workspaceName: String): Future[Workspace] = {
      helper.unpublishLibraryWorkspace(workspaceNamespace, workspaceName)
  }

  /**
   * set the groups that can discover this library dataset 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param discoverableGroups Json array of group names, or empty array for no restrictions 
   * @return Workspace
   */
  def updateDiscoverableGroups(workspaceNamespace: String, workspaceName: String, discoverableGroups: StringArray): Option[Workspace] = {
    val await = Try(Await.result(updateDiscoverableGroupsAsync(workspaceNamespace, workspaceName, discoverableGroups), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * set the groups that can discover this library dataset  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param discoverableGroups Json array of group names, or empty array for no restrictions 
   * @return Future(Workspace)
   */
  def updateDiscoverableGroupsAsync(workspaceNamespace: String, workspaceName: String, discoverableGroups: StringArray): Future[Workspace] = {
      helper.updateDiscoverableGroups(workspaceNamespace, workspaceName, discoverableGroups)
  }

}

class LibraryApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def dataIngest(body: StructuredDataRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[StructuredDataRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/duos/structuredData"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling LibraryApi->dataIngest")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def duosAutocomplete(queryTerm: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/duos/autocomplete/{queryTerm}")
      replaceAll("\\{" + "queryTerm" + "\\}", queryTerm.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (queryTerm == null) throw new Exception("Missing required parameter 'queryTerm' when calling LibraryApi->duosAutocomplete")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def duosConsentOrspId(orspId: String)(implicit reader: ClientResponseReader[Consent]): Future[Consent] = {
    // create path and map variables
    val path = (addFmt("/api/duos/consent/orsp/{orspId}")
      replaceAll("\\{" + "orspId" + "\\}", orspId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (orspId == null) throw new Exception("Missing required parameter 'orspId' when calling LibraryApi->duosConsentOrspId")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def duosResearchPurposeQuery(body: ResearchPurposeRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[ResearchPurposeRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/duos/researchPurposeQuery"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (body == null) throw new Exception("Missing required parameter 'body' when calling LibraryApi->duosResearchPurposeQuery")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def findDocuments(searchParams: Option[SearchTermRef] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[SearchTermRef]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/library/search"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(searchParams))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getDiscoverableGroups(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[StringArray]): Future[StringArray] = {
    // create path and map variables
    val path = (addFmt("/api/library/{workspaceNamespace}/{workspaceName}/discoverableGroups")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling LibraryApi->getDiscoverableGroups")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling LibraryApi->getDiscoverableGroups")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getLibraryMetadata(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[LibraryMetadataInput]): Future[LibraryMetadataInput] = {
    // create path and map variables
    val path = (addFmt("/api/library/{workspaceNamespace}/{workspaceName}/metadata")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling LibraryApi->getLibraryMetadata")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling LibraryApi->getLibraryMetadata")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def groups()(implicit reader: ClientResponseReader[List[String]]): Future[List[String]] = {
    // create path and map variables
    val path = (addFmt("/api/library/groups"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def populateSuggest(field: String,
    q: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/library/populate/suggest/{field}")
      replaceAll("\\{" + "field" + "\\}", field.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (field == null) throw new Exception("Missing required parameter 'field' when calling LibraryApi->populateSuggest")

    if (q == null) throw new Exception("Missing required parameter 'q' when calling LibraryApi->populateSuggest")

    queryParams += "q" -> q.toString

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def publishLibraryWorkspace(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Workspace]): Future[Workspace] = {
    // create path and map variables
    val path = (addFmt("/api/library/{workspaceNamespace}/{workspaceName}/published")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling LibraryApi->publishLibraryWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling LibraryApi->publishLibraryWorkspace")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def putLibraryMetadata(workspaceNamespace: String,
    workspaceName: String,
    libraryMetadataJson: LibraryMetadataInput,
    validate: Option[Boolean] = None
    )(implicit reader: ClientResponseReader[Workspace], writer: RequestWriter[LibraryMetadataInput]): Future[Workspace] = {
    // create path and map variables
    val path = (addFmt("/api/library/{workspaceNamespace}/{workspaceName}/metadata")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling LibraryApi->putLibraryMetadata")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling LibraryApi->putLibraryMetadata")

    if (libraryMetadataJson == null) throw new Exception("Missing required parameter 'libraryMetadataJson' when calling LibraryApi->putLibraryMetadata")
    validate match {
      case Some(param) => queryParams += "validate" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(libraryMetadataJson))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def reindexAll()(implicit reader: ClientResponseReader[LibraryBulkIndexResponse]): Future[LibraryBulkIndexResponse] = {
    // create path and map variables
    val path = (addFmt("/api/library/admin/reindex"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def searchSuggest(searchParams: Option[SearchTermRef] = None
    )(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Option[SearchTermRef]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/library/suggest"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(searchParams))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def unpublishLibraryWorkspace(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Workspace]): Future[Workspace] = {
    // create path and map variables
    val path = (addFmt("/api/library/{workspaceNamespace}/{workspaceName}/published")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling LibraryApi->unpublishLibraryWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling LibraryApi->unpublishLibraryWorkspace")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateDiscoverableGroups(workspaceNamespace: String,
    workspaceName: String,
    discoverableGroups: StringArray)(implicit reader: ClientResponseReader[Workspace], writer: RequestWriter[StringArray]): Future[Workspace] = {
    // create path and map variables
    val path = (addFmt("/api/library/{workspaceNamespace}/{workspaceName}/discoverableGroups")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling LibraryApi->updateDiscoverableGroups")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling LibraryApi->updateDiscoverableGroups")

    if (discoverableGroups == null) throw new Exception("Missing required parameter 'discoverableGroups' when calling LibraryApi->updateDiscoverableGroups")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(discoverableGroups))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
