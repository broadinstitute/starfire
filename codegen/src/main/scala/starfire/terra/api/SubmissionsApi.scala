/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.ErrorReport
import starfire.terra.model.Submission
import starfire.terra.model.SubmissionRequest
import starfire.terra.model.SubmissionValidationReport
import starfire.terra.model.SubmissionsCountResponse
import starfire.terra.model.WorkflowCost
import starfire.terra.model.WorkflowQueueStatusResponse
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class SubmissionsApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new SubmissionsApiAsyncHelper(client, config)

  /**
   * abort a submission 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @return void
   */
  def abortSubmission(workspaceNamespace: String, workspaceName: String, submissionId: String) = {
    val await = Try(Await.result(abortSubmissionAsync(workspaceNamespace, workspaceName, submissionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * abort a submission  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @return Future(void)
   */
  def abortSubmissionAsync(workspaceNamespace: String, workspaceName: String, submissionId: String) = {
      helper.abortSubmission(workspaceNamespace, workspaceName, submissionId)
  }

  /**
   * Count submissions by status
   * Counts all submissions run in the workspace, grouped by status. Returns a map of status:count.
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return SubmissionsCountResponse
   */
  def countSubmissions(workspaceNamespace: String, workspaceName: String): Option[SubmissionsCountResponse] = {
    val await = Try(Await.result(countSubmissionsAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Count submissions by status asynchronously
   * Counts all submissions run in the workspace, grouped by status. Returns a map of status:count.
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(SubmissionsCountResponse)
   */
  def countSubmissionsAsync(workspaceNamespace: String, workspaceName: String): Future[SubmissionsCountResponse] = {
      helper.countSubmissions(workspaceNamespace, workspaceName)
  }

  /**
   * Create a submission. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submission Post Submission 
   * @return void
   */
  def createSubmission(workspaceNamespace: String, workspaceName: String, submission: SubmissionRequest) = {
    val await = Try(Await.result(createSubmissionAsync(workspaceNamespace, workspaceName, submission), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a submission.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submission Post Submission 
   * @return Future(void)
   */
  def createSubmissionAsync(workspaceNamespace: String, workspaceName: String, submission: SubmissionRequest) = {
      helper.createSubmission(workspaceNamespace, workspaceName, submission)
  }

  /**
   * List submissions. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def listSubmissions(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(listSubmissionsAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List submissions.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def listSubmissionsAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.listSubmissions(workspaceNamespace, workspaceName)
  }

  /**
   * Monitor submission status 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @return Submission
   */
  def monitorSubmission(workspaceNamespace: String, workspaceName: String, submissionId: String): Option[Submission] = {
    val await = Try(Await.result(monitorSubmissionAsync(workspaceNamespace, workspaceName, submissionId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Monitor submission status  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @return Future(Submission)
   */
  def monitorSubmissionAsync(workspaceNamespace: String, workspaceName: String, submissionId: String): Future[Submission] = {
      helper.monitorSubmission(workspaceNamespace, workspaceName, submissionId)
  }

  /**
   * Validate submission
   * Validate expression syntax for a submission
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submission Description of a submission. 
   * @return SubmissionValidationReport
   */
  def validateSubmission(workspaceNamespace: String, workspaceName: String, submission: SubmissionRequest): Option[SubmissionValidationReport] = {
    val await = Try(Await.result(validateSubmissionAsync(workspaceNamespace, workspaceName, submission), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Validate submission asynchronously
   * Validate expression syntax for a submission
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submission Description of a submission. 
   * @return Future(SubmissionValidationReport)
   */
  def validateSubmissionAsync(workspaceNamespace: String, workspaceName: String, submission: SubmissionRequest): Future[SubmissionValidationReport] = {
      helper.validateSubmission(workspaceNamespace, workspaceName, submission)
  }

  /**
   * Retrieve workflow cost, if available. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @param workflowId Workflow ID 
   * @return WorkflowCost
   */
  def workflowCostInSubmission(workspaceNamespace: String, workspaceName: String, submissionId: String, workflowId: String): Option[WorkflowCost] = {
    val await = Try(Await.result(workflowCostInSubmissionAsync(workspaceNamespace, workspaceName, submissionId, workflowId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve workflow cost, if available.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @param workflowId Workflow ID 
   * @return Future(WorkflowCost)
   */
  def workflowCostInSubmissionAsync(workspaceNamespace: String, workspaceName: String, submissionId: String, workflowId: String): Future[WorkflowCost] = {
      helper.workflowCostInSubmission(workspaceNamespace, workspaceName, submissionId, workflowId)
  }

  /**
   * Get call-level metadata for workflow
   * Get call-level metadata for workflow
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @param workflowId Workflow ID 
   * @param includeKey When specified, return only these keys in the response. Matches any key in the response, including within nested blocks. May not be used with excludeKey.  (optional)
   * @param excludeKey When specified, omit these keys from the response. Matches any key in the response, including within nested blocks. May not be used with includeKey.  (optional)
   * @param expandSubWorkflows When true, metadata for sub workflows will be fetched and inserted automatically in the metadata response.  (optional, default to false)
   * @return void
   */
  def workflowMetadata(workspaceNamespace: String, workspaceName: String, submissionId: String, workflowId: String, includeKey: Option[List[String]] = None, excludeKey: Option[List[String]] = None, expandSubWorkflows: Option[Boolean] = Option(false)) = {
    val await = Try(Await.result(workflowMetadataAsync(workspaceNamespace, workspaceName, submissionId, workflowId, includeKey, excludeKey, expandSubWorkflows), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get call-level metadata for workflow asynchronously
   * Get call-level metadata for workflow
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @param workflowId Workflow ID 
   * @param includeKey When specified, return only these keys in the response. Matches any key in the response, including within nested blocks. May not be used with excludeKey.  (optional)
   * @param excludeKey When specified, omit these keys from the response. Matches any key in the response, including within nested blocks. May not be used with includeKey.  (optional)
   * @param expandSubWorkflows When true, metadata for sub workflows will be fetched and inserted automatically in the metadata response.  (optional, default to false)
   * @return Future(void)
   */
  def workflowMetadataAsync(workspaceNamespace: String, workspaceName: String, submissionId: String, workflowId: String, includeKey: Option[List[String]] = None, excludeKey: Option[List[String]] = None, expandSubWorkflows: Option[Boolean] = Option(false)) = {
      helper.workflowMetadata(workspaceNamespace, workspaceName, submissionId, workflowId, includeKey, excludeKey, expandSubWorkflows)
  }

  /**
   * Get workflow outputs. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @param workflowId Workflow ID 
   * @return void
   */
  def workflowOutputsInSubmission(workspaceNamespace: String, workspaceName: String, submissionId: String, workflowId: String) = {
    val await = Try(Await.result(workflowOutputsInSubmissionAsync(workspaceNamespace, workspaceName, submissionId, workflowId), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get workflow outputs.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param submissionId Submission ID 
   * @param workflowId Workflow ID 
   * @return Future(void)
   */
  def workflowOutputsInSubmissionAsync(workspaceNamespace: String, workspaceName: String, submissionId: String, workflowId: String) = {
      helper.workflowOutputsInSubmission(workspaceNamespace, workspaceName, submissionId, workflowId)
  }

  /**
   * workflow queue status
   * List workflow counts by queueing state
   *
   * @return WorkflowQueueStatusResponse
   */
  def workflowQueueStatus(): Option[WorkflowQueueStatusResponse] = {
    val await = Try(Await.result(workflowQueueStatusAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * workflow queue status asynchronously
   * List workflow counts by queueing state
   *
   * @return Future(WorkflowQueueStatusResponse)
   */
  def workflowQueueStatusAsync(): Future[WorkflowQueueStatusResponse] = {
      helper.workflowQueueStatus()
  }

}

class SubmissionsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def abortSubmission(workspaceNamespace: String,
    workspaceName: String,
    submissionId: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions/{submissionId}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "submissionId" + "\\}", submissionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->abortSubmission")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->abortSubmission")

    if (submissionId == null) throw new Exception("Missing required parameter 'submissionId' when calling SubmissionsApi->abortSubmission")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def countSubmissions(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[SubmissionsCountResponse]): Future[SubmissionsCountResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissionsCount")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->countSubmissions")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->countSubmissions")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createSubmission(workspaceNamespace: String,
    workspaceName: String,
    submission: SubmissionRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[SubmissionRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->createSubmission")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->createSubmission")

    if (submission == null) throw new Exception("Missing required parameter 'submission' when calling SubmissionsApi->createSubmission")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(submission))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listSubmissions(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->listSubmissions")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->listSubmissions")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def monitorSubmission(workspaceNamespace: String,
    workspaceName: String,
    submissionId: String)(implicit reader: ClientResponseReader[Submission]): Future[Submission] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions/{submissionId}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "submissionId" + "\\}", submissionId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->monitorSubmission")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->monitorSubmission")

    if (submissionId == null) throw new Exception("Missing required parameter 'submissionId' when calling SubmissionsApi->monitorSubmission")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def validateSubmission(workspaceNamespace: String,
    workspaceName: String,
    submission: SubmissionRequest)(implicit reader: ClientResponseReader[SubmissionValidationReport], writer: RequestWriter[SubmissionRequest]): Future[SubmissionValidationReport] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions/validate")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->validateSubmission")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->validateSubmission")

    if (submission == null) throw new Exception("Missing required parameter 'submission' when calling SubmissionsApi->validateSubmission")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(submission))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def workflowCostInSubmission(workspaceNamespace: String,
    workspaceName: String,
    submissionId: String,
    workflowId: String)(implicit reader: ClientResponseReader[WorkflowCost]): Future[WorkflowCost] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions/{submissionId}/workflows/{workflowId}/cost")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "submissionId" + "\\}", submissionId.toString)
      replaceAll("\\{" + "workflowId" + "\\}", workflowId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->workflowCostInSubmission")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->workflowCostInSubmission")

    if (submissionId == null) throw new Exception("Missing required parameter 'submissionId' when calling SubmissionsApi->workflowCostInSubmission")

    if (workflowId == null) throw new Exception("Missing required parameter 'workflowId' when calling SubmissionsApi->workflowCostInSubmission")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def workflowMetadata(workspaceNamespace: String,
    workspaceName: String,
    submissionId: String,
    workflowId: String,
    includeKey: Option[List[String]] = None,
    excludeKey: Option[List[String]] = None,
    expandSubWorkflows: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions/{submissionId}/workflows/{workflowId}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "submissionId" + "\\}", submissionId.toString)
      replaceAll("\\{" + "workflowId" + "\\}", workflowId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->workflowMetadata")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->workflowMetadata")

    if (submissionId == null) throw new Exception("Missing required parameter 'submissionId' when calling SubmissionsApi->workflowMetadata")

    if (workflowId == null) throw new Exception("Missing required parameter 'workflowId' when calling SubmissionsApi->workflowMetadata")

    includeKey match {
      case Some(param) => queryParams += "includeKey" -> param.toString
      case _ => queryParams
    }
    excludeKey match {
      case Some(param) => queryParams += "excludeKey" -> param.toString
      case _ => queryParams
    }
    expandSubWorkflows match {
      case Some(param) => queryParams += "expandSubWorkflows" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def workflowOutputsInSubmission(workspaceNamespace: String,
    workspaceName: String,
    submissionId: String,
    workflowId: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/submissions/{submissionId}/workflows/{workflowId}/outputs")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "submissionId" + "\\}", submissionId.toString)
      replaceAll("\\{" + "workflowId" + "\\}", workflowId.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling SubmissionsApi->workflowOutputsInSubmission")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling SubmissionsApi->workflowOutputsInSubmission")

    if (submissionId == null) throw new Exception("Missing required parameter 'submissionId' when calling SubmissionsApi->workflowOutputsInSubmission")

    if (workflowId == null) throw new Exception("Missing required parameter 'workflowId' when calling SubmissionsApi->workflowOutputsInSubmission")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def workflowQueueStatus()(implicit reader: ClientResponseReader[WorkflowQueueStatusResponse]): Future[WorkflowQueueStatusResponse] = {
    // create path and map variables
    val path = (addFmt("/api/submissions/queueStatus"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
