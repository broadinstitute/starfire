/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.AttributeUpdateOperation
import starfire.terra.model.BagitRequest
import starfire.terra.model.CopyEntity
import starfire.terra.model.Entity
import starfire.terra.model.EntityCopyResponse
import starfire.terra.model.EntityID
import starfire.terra.model.EntityQueryResponse
import starfire.terra.model.ErrorReport
import java.io.File
import starfire.terra.model.Number
import starfire.terra.model.PFBRequest
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class EntitiesApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new EntitiesApiAsyncHelper(client, config)

  /**
   * TSV file containing workspace entities of the specified type 
   * swagger-ui seems to not handle file downloads, so this endpoint won&#39;t function through the ui. It is here for documentation purposes only. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param fCtoken valid access token to use for authentication 
   * @param attributeNames comma separated list of ordered attribute names to be in downloaded tsv (optional)
   * @param model flexible or firecloud (firecloud model will be used by default) (optional)
   * @return File
   */
  def browserDownloadEntitiesTSV(workspaceNamespace: String, workspaceName: String, entityType: String, fCtoken: String, attributeNames: Option[String] = None, model: Option[String] = None): Option[File] = {
    val await = Try(Await.result(browserDownloadEntitiesTSVAsync(workspaceNamespace, workspaceName, entityType, fCtoken, attributeNames, model), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * TSV file containing workspace entities of the specified type  asynchronously
   * swagger-ui seems to not handle file downloads, so this endpoint won&#39;t function through the ui. It is here for documentation purposes only. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param fCtoken valid access token to use for authentication 
   * @param attributeNames comma separated list of ordered attribute names to be in downloaded tsv (optional)
   * @param model flexible or firecloud (firecloud model will be used by default) (optional)
   * @return Future(File)
   */
  def browserDownloadEntitiesTSVAsync(workspaceNamespace: String, workspaceName: String, entityType: String, fCtoken: String, attributeNames: Option[String] = None, model: Option[String] = None): Future[File] = {
      helper.browserDownloadEntitiesTSV(workspaceNamespace, workspaceName, entityType, fCtoken, attributeNames, model)
  }

  /**
   * TSV file containing workspace entities of the specified type 
   * swagger-ui seems to not handle file downloads, so this endpoint won&#39;t function through the ui. It is here for documentation purposes only. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param attributeNames comma separated list of ordered attribute names to be in downloaded tsv (optional)
   * @param model flexible or firecloud (firecloud model will be used by default) (optional)
   * @return File
   */
  def browserDownloadEntitiesTSVGet(workspaceNamespace: String, workspaceName: String, entityType: String, attributeNames: Option[String] = None, model: Option[String] = None): Option[File] = {
    val await = Try(Await.result(browserDownloadEntitiesTSVGetAsync(workspaceNamespace, workspaceName, entityType, attributeNames, model), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * TSV file containing workspace entities of the specified type  asynchronously
   * swagger-ui seems to not handle file downloads, so this endpoint won&#39;t function through the ui. It is here for documentation purposes only. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param attributeNames comma separated list of ordered attribute names to be in downloaded tsv (optional)
   * @param model flexible or firecloud (firecloud model will be used by default) (optional)
   * @return Future(File)
   */
  def browserDownloadEntitiesTSVGetAsync(workspaceNamespace: String, workspaceName: String, entityType: String, attributeNames: Option[String] = None, model: Option[String] = None): Future[File] = {
      helper.browserDownloadEntitiesTSVGet(workspaceNamespace, workspaceName, entityType, attributeNames, model)
  }

  /**
   * Copy entities from one workspace to another 
   * 
   *
   * @param workspaceNamespace Destination Workspace Namespace 
   * @param workspaceName Destination Workspace Name 
   * @param body Entities to Copy 
   * @param linkExistingEntities true to link new entities to existing entities, false to fail instead of link (optional, default to false)
   * @return EntityCopyResponse
   */
  def copyEntities(workspaceNamespace: String, workspaceName: String, body: CopyEntity, linkExistingEntities: Option[Boolean] = Option(false)): Option[EntityCopyResponse] = {
    val await = Try(Await.result(copyEntitiesAsync(workspaceNamespace, workspaceName, body, linkExistingEntities), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Copy entities from one workspace to another  asynchronously
   * 
   *
   * @param workspaceNamespace Destination Workspace Namespace 
   * @param workspaceName Destination Workspace Name 
   * @param body Entities to Copy 
   * @param linkExistingEntities true to link new entities to existing entities, false to fail instead of link (optional, default to false)
   * @return Future(EntityCopyResponse)
   */
  def copyEntitiesAsync(workspaceNamespace: String, workspaceName: String, body: CopyEntity, linkExistingEntities: Option[Boolean] = Option(false)): Future[EntityCopyResponse] = {
      helper.copyEntities(workspaceNamespace, workspaceName, body, linkExistingEntities)
  }

  /**
   * Bulk delete entities from a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param body Entities to delete 
   * @return void
   */
  def deleteEntities(workspaceNamespace: String, workspaceName: String, body: List[EntityID]) = {
    val await = Try(Await.result(deleteEntitiesAsync(workspaceNamespace, workspaceName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Bulk delete entities from a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param body Entities to delete 
   * @return Future(void)
   */
  def deleteEntitiesAsync(workspaceNamespace: String, workspaceName: String, body: List[EntityID]) = {
      helper.deleteEntities(workspaceNamespace, workspaceName, body)
  }

  /**
   * TSV file containing workspace entities of the specified type 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param attributeNames comma separated list of ordered attribute names to be in downloaded tsv (optional)
   * @param model firecloud (default) or flexible (optional)
   * @return File
   */
  def downloadEntitiesTSV(workspaceNamespace: String, workspaceName: String, entityType: String, attributeNames: Option[String] = None, model: Option[String] = None): Option[File] = {
    val await = Try(Await.result(downloadEntitiesTSVAsync(workspaceNamespace, workspaceName, entityType, attributeNames, model), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * TSV file containing workspace entities of the specified type  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param attributeNames comma separated list of ordered attribute names to be in downloaded tsv (optional)
   * @param model firecloud (default) or flexible (optional)
   * @return Future(File)
   */
  def downloadEntitiesTSVAsync(workspaceNamespace: String, workspaceName: String, entityType: String, attributeNames: Option[String] = None, model: Option[String] = None): Future[File] = {
      helper.downloadEntitiesTSV(workspaceNamespace, workspaceName, entityType, attributeNames, model)
  }

  /**
   * Paginated query for entities in a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param page Page number, 1-indexed (default 1) (optional, default to 1)
   * @param pageSize Page size (default 10) (optional, default to 10)
   * @param sortField Sort field (default \&quot;name\&quot;) (optional, default to name)
   * @param sortDirection Sort direction (asc or desc, default asc) (optional, default to asc)
   * @param filterTerms Filter terms (optional)
   * @return EntityQueryResponse
   */
  def entityQuery(workspaceNamespace: String, workspaceName: String, entityType: String, page: Option[Number] = Option(1), pageSize: Option[Number] = Option(10), sortField: Option[String] = Option("name"), sortDirection: Option[String] = Option("asc"), filterTerms: Option[String] = None): Option[EntityQueryResponse] = {
    val await = Try(Await.result(entityQueryAsync(workspaceNamespace, workspaceName, entityType, page, pageSize, sortField, sortDirection, filterTerms), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Paginated query for entities in a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param page Page number, 1-indexed (default 1) (optional, default to 1)
   * @param pageSize Page size (default 10) (optional, default to 10)
   * @param sortField Sort field (default \&quot;name\&quot;) (optional, default to name)
   * @param sortDirection Sort direction (asc or desc, default asc) (optional, default to asc)
   * @param filterTerms Filter terms (optional)
   * @return Future(EntityQueryResponse)
   */
  def entityQueryAsync(workspaceNamespace: String, workspaceName: String, entityType: String, page: Option[Number] = Option(1), pageSize: Option[Number] = Option(10), sortField: Option[String] = Option("name"), sortDirection: Option[String] = Option("asc"), filterTerms: Option[String] = None): Future[EntityQueryResponse] = {
      helper.entityQuery(workspaceNamespace, workspaceName, entityType, page, pageSize, sortField, sortDirection, filterTerms)
  }

  /**
   * Evaluate entity expression
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param entityName Entity Name 
   * @param expression Expression 
   * @return void
   */
  def evaluateEntityExpression(workspaceNamespace: String, workspaceName: String, entityType: String, entityName: String, expression: String) = {
    val await = Try(Await.result(evaluateEntityExpressionAsync(workspaceNamespace, workspaceName, entityType, entityName, expression), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Evaluate entity expression asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param entityName Entity Name 
   * @param expression Expression 
   * @return Future(void)
   */
  def evaluateEntityExpressionAsync(workspaceNamespace: String, workspaceName: String, entityType: String, entityName: String, expression: String) = {
      helper.evaluateEntityExpression(workspaceNamespace, workspaceName, entityType, entityName, expression)
  }

  /**
   * Import entities from a tsv file
   * 
   *
   * @param workspaceNamespace Destination Workspace Namespace 
   * @param workspaceName Destination Workspace Name 
   * @param entities A valid TSV import file 
   * @return void
   */
  def flexibleImportEntities(workspaceNamespace: String, workspaceName: String, entities: File) = {
    val await = Try(Await.result(flexibleImportEntitiesAsync(workspaceNamespace, workspaceName, entities), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Import entities from a tsv file asynchronously
   * 
   *
   * @param workspaceNamespace Destination Workspace Namespace 
   * @param workspaceName Destination Workspace Name 
   * @param entities A valid TSV import file 
   * @return Future(void)
   */
  def flexibleImportEntitiesAsync(workspaceNamespace: String, workspaceName: String, entities: File) = {
      helper.flexibleImportEntities(workspaceNamespace, workspaceName, entities)
  }

  /**
   * List of entities in a workspace 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @return List[Entity]
   */
  def getEntities(workspaceNamespace: String, workspaceName: String, entityType: String): Option[List[Entity]] = {
    val await = Try(Await.result(getEntitiesAsync(workspaceNamespace, workspaceName, entityType), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List of entities in a workspace  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @return Future(List[Entity])
   */
  def getEntitiesAsync(workspaceNamespace: String, workspaceName: String, entityType: String): Future[List[Entity]] = {
      helper.getEntities(workspaceNamespace, workspaceName, entityType)
  }

  /**
   * List of entities in a workspace with type and attribute information 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def getEntitiesWithType(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(getEntitiesWithTypeAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List of entities in a workspace with type and attribute information  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def getEntitiesWithTypeAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.getEntitiesWithType(workspaceNamespace, workspaceName)
  }

  /**
   * Get entity in a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param entityName Entity Name 
   * @return void
   */
  def getEntity(workspaceNamespace: String, workspaceName: String, entityType: String, entityName: String) = {
    val await = Try(Await.result(getEntityAsync(workspaceNamespace, workspaceName, entityType, entityName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get entity in a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param entityName Entity Name 
   * @return Future(void)
   */
  def getEntityAsync(workspaceNamespace: String, workspaceName: String, entityType: String, entityName: String) = {
      helper.getEntity(workspaceNamespace, workspaceName, entityType, entityName)
  }

  /**
   * List of entity types in a workspace 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def getEntityTypes(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(getEntityTypesAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List of entity types in a workspace  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def getEntityTypesAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.getEntityTypes(workspaceNamespace, workspaceName)
  }

  /**
   * Import entity TSVs from a zipped [BagIt](https://tools.ietf.org/html/draft-kunze-bagit-14) directory, whose payload contains two files - participants.tsv and samples.tsv
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param bagitImportRequest JSON object containing bagit URL 
   * @return void
   */
  def importBagit(workspaceNamespace: String, workspaceName: String, bagitImportRequest: BagitRequest) = {
    val await = Try(Await.result(importBagitAsync(workspaceNamespace, workspaceName, bagitImportRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Import entity TSVs from a zipped [BagIt](https://tools.ietf.org/html/draft-kunze-bagit-14) directory, whose payload contains two files - participants.tsv and samples.tsv asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param bagitImportRequest JSON object containing bagit URL 
   * @return Future(void)
   */
  def importBagitAsync(workspaceNamespace: String, workspaceName: String, bagitImportRequest: BagitRequest) = {
      helper.importBagit(workspaceNamespace, workspaceName, bagitImportRequest)
  }

  /**
   * Import entities from a tsv file
   * 
   *
   * @param workspaceNamespace Destination Workspace Namespace 
   * @param workspaceName Destination Workspace Name 
   * @param entities A valid TSV import file 
   * @return void
   */
  def importEntities(workspaceNamespace: String, workspaceName: String, entities: File) = {
    val await = Try(Await.result(importEntitiesAsync(workspaceNamespace, workspaceName, entities), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Import entities from a tsv file asynchronously
   * 
   *
   * @param workspaceNamespace Destination Workspace Namespace 
   * @param workspaceName Destination Workspace Name 
   * @param entities A valid TSV import file 
   * @return Future(void)
   */
  def importEntitiesAsync(workspaceNamespace: String, workspaceName: String, entities: File) = {
      helper.importEntities(workspaceNamespace, workspaceName, entities)
  }

  /**
   * Import PFB data from an [Avro](https://avro.apache.org/) file
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param pfbImportRequest JSON object containing PFB URL 
   * @return void
   */
  def importPFB(workspaceNamespace: String, workspaceName: String, pfbImportRequest: PFBRequest) = {
    val await = Try(Await.result(importPFBAsync(workspaceNamespace, workspaceName, pfbImportRequest), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Import PFB data from an [Avro](https://avro.apache.org/) file asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param pfbImportRequest JSON object containing PFB URL 
   * @return Future(void)
   */
  def importPFBAsync(workspaceNamespace: String, workspaceName: String, pfbImportRequest: PFBRequest) = {
      helper.importPFB(workspaceNamespace, workspaceName, pfbImportRequest)
  }

  /**
   * Update entity in a workspace
   * Update an entity
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param entityName Entity Name 
   * @param attributeUpdateJson Update operations for attributes (optional)
   * @return Entity
   */
  def updateEntity(workspaceNamespace: String, workspaceName: String, entityType: String, entityName: String, attributeUpdateJson: Option[AttributeUpdateOperation] = None): Option[Entity] = {
    val await = Try(Await.result(updateEntityAsync(workspaceNamespace, workspaceName, entityType, entityName, attributeUpdateJson), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update entity in a workspace asynchronously
   * Update an entity
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param entityType Entity Type 
   * @param entityName Entity Name 
   * @param attributeUpdateJson Update operations for attributes (optional)
   * @return Future(Entity)
   */
  def updateEntityAsync(workspaceNamespace: String, workspaceName: String, entityType: String, entityName: String, attributeUpdateJson: Option[AttributeUpdateOperation] = None): Future[Entity] = {
      helper.updateEntity(workspaceNamespace, workspaceName, entityType, entityName, attributeUpdateJson)
  }

}

class EntitiesApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def browserDownloadEntitiesTSV(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    fCtoken: String,
    attributeNames: Option[String] = None,
    model: Option[String] = None
    )(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/cookie-authed/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}/tsv")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->browserDownloadEntitiesTSV")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->browserDownloadEntitiesTSV")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->browserDownloadEntitiesTSV")

    if (fCtoken == null) throw new Exception("Missing required parameter 'fCtoken' when calling EntitiesApi->browserDownloadEntitiesTSV")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def browserDownloadEntitiesTSVGet(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    attributeNames: Option[String] = None,
    model: Option[String] = None
    )(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/cookie-authed/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}/tsv")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->browserDownloadEntitiesTSVGet")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->browserDownloadEntitiesTSVGet")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->browserDownloadEntitiesTSVGet")

    attributeNames match {
      case Some(param) => queryParams += "attributeNames" -> param.toString
      case _ => queryParams
    }
    model match {
      case Some(param) => queryParams += "model" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def copyEntities(workspaceNamespace: String,
    workspaceName: String,
    body: CopyEntity,
    linkExistingEntities: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[EntityCopyResponse], writer: RequestWriter[CopyEntity]): Future[EntityCopyResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/copy")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->copyEntities")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->copyEntities")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling EntitiesApi->copyEntities")
    linkExistingEntities match {
      case Some(param) => queryParams += "linkExistingEntities" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteEntities(workspaceNamespace: String,
    workspaceName: String,
    body: List[EntityID])(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[List[EntityID]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/delete")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->deleteEntities")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->deleteEntities")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling EntitiesApi->deleteEntities")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def downloadEntitiesTSV(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    attributeNames: Option[String] = None,
    model: Option[String] = None
    )(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}/tsv")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->downloadEntitiesTSV")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->downloadEntitiesTSV")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->downloadEntitiesTSV")

    attributeNames match {
      case Some(param) => queryParams += "attributeNames" -> param.toString
      case _ => queryParams
    }
    model match {
      case Some(param) => queryParams += "model" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def entityQuery(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    page: Option[Number] = Option(1),
    pageSize: Option[Number] = Option(10),
    sortField: Option[String] = Option("name"),
    sortDirection: Option[String] = Option("asc"),
    filterTerms: Option[String] = None
    )(implicit reader: ClientResponseReader[EntityQueryResponse]): Future[EntityQueryResponse] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entityQuery/{entityType}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->entityQuery")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->entityQuery")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->entityQuery")

    page match {
      case Some(param) => queryParams += "page" -> param.toString
      case _ => queryParams
    }
    pageSize match {
      case Some(param) => queryParams += "pageSize" -> param.toString
      case _ => queryParams
    }
    sortField match {
      case Some(param) => queryParams += "sortField" -> param.toString
      case _ => queryParams
    }
    sortDirection match {
      case Some(param) => queryParams += "sortDirection" -> param.toString
      case _ => queryParams
    }
    filterTerms match {
      case Some(param) => queryParams += "filterTerms" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def evaluateEntityExpression(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    entityName: String,
    expression: String)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[String]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}/{entityName}/evaluate")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString)
      replaceAll("\\{" + "entityName" + "\\}", entityName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->evaluateEntityExpression")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->evaluateEntityExpression")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->evaluateEntityExpression")

    if (entityName == null) throw new Exception("Missing required parameter 'entityName' when calling EntitiesApi->evaluateEntityExpression")

    if (expression == null) throw new Exception("Missing required parameter 'expression' when calling EntitiesApi->evaluateEntityExpression")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(expression))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def flexibleImportEntities(workspaceNamespace: String,
    workspaceName: String,
    entities: File)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/flexibleImportEntities")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->flexibleImportEntities")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->flexibleImportEntities")

    if (entities == null) throw new Exception("Missing required parameter 'entities' when calling EntitiesApi->flexibleImportEntities")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntities(workspaceNamespace: String,
    workspaceName: String,
    entityType: String)(implicit reader: ClientResponseReader[List[Entity]]): Future[List[Entity]] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->getEntities")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->getEntities")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->getEntities")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntitiesWithType(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities_with_type")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->getEntitiesWithType")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->getEntitiesWithType")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntity(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    entityName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}/{entityName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString)
      replaceAll("\\{" + "entityName" + "\\}", entityName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->getEntity")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->getEntity")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->getEntity")

    if (entityName == null) throw new Exception("Missing required parameter 'entityName' when calling EntitiesApi->getEntity")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getEntityTypes(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->getEntityTypes")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->getEntityTypes")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def importBagit(workspaceNamespace: String,
    workspaceName: String,
    bagitImportRequest: BagitRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[BagitRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/importBagit")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->importBagit")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->importBagit")

    if (bagitImportRequest == null) throw new Exception("Missing required parameter 'bagitImportRequest' when calling EntitiesApi->importBagit")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(bagitImportRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def importEntities(workspaceNamespace: String,
    workspaceName: String,
    entities: File)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/importEntities")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->importEntities")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->importEntities")

    if (entities == null) throw new Exception("Missing required parameter 'entities' when calling EntitiesApi->importEntities")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def importPFB(workspaceNamespace: String,
    workspaceName: String,
    pfbImportRequest: PFBRequest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[PFBRequest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/importPFB")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->importPFB")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->importPFB")

    if (pfbImportRequest == null) throw new Exception("Missing required parameter 'pfbImportRequest' when calling EntitiesApi->importPFB")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(pfbImportRequest))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateEntity(workspaceNamespace: String,
    workspaceName: String,
    entityType: String,
    entityName: String,
    attributeUpdateJson: Option[AttributeUpdateOperation] = None
    )(implicit reader: ClientResponseReader[Entity], writer: RequestWriter[Option[AttributeUpdateOperation]]): Future[Entity] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/entities/{entityType}/{entityName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "entityType" + "\\}", entityType.toString)
      replaceAll("\\{" + "entityName" + "\\}", entityName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling EntitiesApi->updateEntity")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling EntitiesApi->updateEntity")

    if (entityType == null) throw new Exception("Missing required parameter 'entityType' when calling EntitiesApi->updateEntity")

    if (entityName == null) throw new Exception("Missing required parameter 'entityName' when calling EntitiesApi->updateEntity")


    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(attributeUpdateJson))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
