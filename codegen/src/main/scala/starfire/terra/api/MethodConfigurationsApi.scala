/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.ConfigurationIngest
import starfire.terra.model.CopyConfigurationIngest
import starfire.terra.model.MethodConfigRename
import starfire.terra.model.NewMethodConfigIngest
import starfire.terra.model.PermissionReport
import starfire.terra.model.PermissionReportRequest
import starfire.terra.model.PublishConfigurationIngest
import starfire.terra.model.UserImportPermission
import starfire.terra.model.ValidatedMethodConfiguration
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class MethodConfigurationsApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new MethodConfigurationsApiAsyncHelper(client, config)

  /**
   * Copy a Method Repository Configuration into a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return void
   */
  def copyFromMethodRepo(workspaceNamespace: String, workspaceName: String, configToCopy: CopyConfigurationIngest) = {
    val await = Try(Await.result(copyFromMethodRepoAsync(workspaceNamespace, workspaceName, configToCopy), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Copy a Method Repository Configuration into a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return Future(void)
   */
  def copyFromMethodRepoAsync(workspaceNamespace: String, workspaceName: String, configToCopy: CopyConfigurationIngest) = {
      helper.copyFromMethodRepo(workspaceNamespace, workspaceName, configToCopy)
  }

  /**
   * Copy a Method Config in a workspace to the Method Repository
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return void
   */
  def copyToMethodRepo(workspaceNamespace: String, workspaceName: String, configToCopy: PublishConfigurationIngest) = {
    val await = Try(Await.result(copyToMethodRepoAsync(workspaceNamespace, workspaceName, configToCopy), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Copy a Method Config in a workspace to the Method Repository asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configToCopy Method Configuration to Copy 
   * @return Future(void)
   */
  def copyToMethodRepoAsync(workspaceNamespace: String, workspaceName: String, configToCopy: PublishConfigurationIngest) = {
      helper.copyToMethodRepo(workspaceNamespace, workspaceName, configToCopy)
  }

  /**
   * Delete a method configuration in a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @return void
   */
  def deleteWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String) = {
    val await = Try(Await.result(deleteWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, configNamespace, configName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete a method configuration in a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @return Future(void)
   */
  def deleteWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String) = {
      helper.deleteWorkspaceMethodConfig(workspaceNamespace, workspaceName, configNamespace, configName)
  }

  /**
   * Get a method configuration in a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @return void
   */
  def getWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String) = {
    val await = Try(Await.result(getWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, configNamespace, configName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get a method configuration in a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @return Future(void)
   */
  def getWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String) = {
      helper.getWorkspaceMethodConfig(workspaceNamespace, workspaceName, configNamespace, configName)
  }

  /**
   * Check the user&#39;s ability to import a method config into a workspace
   * 
   *
   * @return UserImportPermission
   */
  def importStatus(): Option[UserImportPermission] = {
    val await = Try(Await.result(importStatusAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Check the user&#39;s ability to import a method config into a workspace asynchronously
   * 
   *
   * @return Future(UserImportPermission)
   */
  def importStatusAsync(): Future[UserImportPermission] = {
      helper.importStatus()
  }

  /**
   * List method configurations in a workspace
   * List method configurations in a workspace. By default, only Agora method configs are returned. To return configs for all repos, specify &#x60;allRepos&#x60; to be &#x60;true&#x60;.  #### Expanded discussion on the methodRepoMethod field  This endpoint returns method references to Agora in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; and for Dockstore in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot;,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; If you are only working with Agora methods, the fields &#x60;\&quot;sourceRepo\&quot;&#x60; and &#x60;\&quot;methodUri\&quot;&#x60; can be considered informational and do not need to be round-tripped (see the corresponding &#x60;POST /api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs&#x60; for more details). 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param allRepos Configs for all repos, not just Agora (optional, default to false)
   * @return void
   */
  def listWorkspaceMethodConfigs(workspaceNamespace: String, workspaceName: String, allRepos: Option[Boolean] = Option(false)) = {
    val await = Try(Await.result(listWorkspaceMethodConfigsAsync(workspaceNamespace, workspaceName, allRepos), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List method configurations in a workspace asynchronously
   * List method configurations in a workspace. By default, only Agora method configs are returned. To return configs for all repos, specify &#x60;allRepos&#x60; to be &#x60;true&#x60;.  #### Expanded discussion on the methodRepoMethod field  This endpoint returns method references to Agora in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; and for Dockstore in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot;,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; If you are only working with Agora methods, the fields &#x60;\&quot;sourceRepo\&quot;&#x60; and &#x60;\&quot;methodUri\&quot;&#x60; can be considered informational and do not need to be round-tripped (see the corresponding &#x60;POST /api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs&#x60; for more details). 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param allRepos Configs for all repos, not just Agora (optional, default to false)
   * @return Future(void)
   */
  def listWorkspaceMethodConfigsAsync(workspaceNamespace: String, workspaceName: String, allRepos: Option[Boolean] = Option(false)) = {
      helper.listWorkspaceMethodConfigs(workspaceNamespace, workspaceName, allRepos)
  }

  /**
   * Add or overwrite a method configuration in a workspace
   * Add or overwrite a method configuration in a workspace. The method configuration name and namespace in the URI must match the values in the JSON. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @param body Method Config to Update 
   * @return void
   */
  def overwriteWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String, body: ConfigurationIngest) = {
    val await = Try(Await.result(overwriteWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, configNamespace, configName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add or overwrite a method configuration in a workspace asynchronously
   * Add or overwrite a method configuration in a workspace. The method configuration name and namespace in the URI must match the values in the JSON. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @param body Method Config to Update 
   * @return Future(void)
   */
  def overwriteWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String, body: ConfigurationIngest) = {
      helper.overwriteWorkspaceMethodConfig(workspaceNamespace, workspaceName, configNamespace, configName, body)
  }

  /**
   * Create a Method Configuration in a workspace
   * Create method configurations. #### Expanded discussion on the methodRepoMethod field To create a method config for an Agora method, &#x60;\&quot;sourceRepo\&quot;: \&quot;agora\&quot;&#x60; is optional; the following is sufficient: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1 } &#x60;&#x60;&#x60; To create a method config for a Dockstore method, &#x60;\&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;&#x60; is required: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;,   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot; } &#x60;&#x60;&#x60; You may also use the URI on its own to create a config referencing any supported repo (currently Agora and Dockstore): &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; The system is specified to check for a URI first before falling back to the legacy fields. Unsupported repos will return a 400 Bad Request. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param methodConfigJson Method Configuration contents 
   * @return void
   */
  def postWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, methodConfigJson: NewMethodConfigIngest) = {
    val await = Try(Await.result(postWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, methodConfigJson), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a Method Configuration in a workspace asynchronously
   * Create method configurations. #### Expanded discussion on the methodRepoMethod field To create a method config for an Agora method, &#x60;\&quot;sourceRepo\&quot;: \&quot;agora\&quot;&#x60; is optional; the following is sufficient: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1 } &#x60;&#x60;&#x60; To create a method config for a Dockstore method, &#x60;\&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;&#x60; is required: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;,   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot; } &#x60;&#x60;&#x60; You may also use the URI on its own to create a config referencing any supported repo (currently Agora and Dockstore): &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; The system is specified to check for a URI first before falling back to the legacy fields. Unsupported repos will return a 400 Bad Request. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param methodConfigJson Method Configuration contents 
   * @return Future(void)
   */
  def postWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, methodConfigJson: NewMethodConfigIngest) = {
      helper.postWorkspaceMethodConfig(workspaceNamespace, workspaceName, methodConfigJson)
  }

  /**
   * Rename a method configuration in a workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @param rename Method Config Rename 
   * @return void
   */
  def renameWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String, rename: MethodConfigRename) = {
    val await = Try(Await.result(renameWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, configNamespace, configName, rename), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Rename a method configuration in a workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @param rename Method Config Rename 
   * @return Future(void)
   */
  def renameWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String, rename: MethodConfigRename) = {
      helper.renameWorkspaceMethodConfig(workspaceNamespace, workspaceName, configNamespace, configName, rename)
  }

  /**
   * Update a method configuration in a workspace
   * Update method configuration. Updates and moves the method configuration at the URI to the location in the request body. The location in the URI may be the same as the location in the request body. If the location in the request body matches the location in the URI, it is overwritten. If the location in the request body is different to the location in the URI, and there is a method config already at that location, 409 is returned. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @param body Method Config to Update 
   * @return void
   */
  def updateWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String, body: ConfigurationIngest) = {
    val await = Try(Await.result(updateWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, configNamespace, configName, body), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update a method configuration in a workspace asynchronously
   * Update method configuration. Updates and moves the method configuration at the URI to the location in the request body. The location in the URI may be the same as the location in the request body. If the location in the request body matches the location in the URI, it is overwritten. If the location in the request body is different to the location in the URI, and there is a method config already at that location, 409 is returned. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Configuration Namespace 
   * @param configName Configuration Name 
   * @param body Method Config to Update 
   * @return Future(void)
   */
  def updateWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String, body: ConfigurationIngest) = {
      helper.updateWorkspaceMethodConfig(workspaceNamespace, workspaceName, configNamespace, configName, body)
  }

  /**
   * get syntax validation information for a method configuration
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Method Configuration Namespace 
   * @param configName Method Configuration Name 
   * @return ValidatedMethodConfiguration
   */
  def validateMethodConfiguration(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String): Option[ValidatedMethodConfiguration] = {
    val await = Try(Await.result(validateMethodConfigurationAsync(workspaceNamespace, workspaceName, configNamespace, configName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * get syntax validation information for a method configuration asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param configNamespace Method Configuration Namespace 
   * @param configName Method Configuration Name 
   * @return Future(ValidatedMethodConfiguration)
   */
  def validateMethodConfigurationAsync(workspaceNamespace: String, workspaceName: String, configNamespace: String, configName: String): Future[ValidatedMethodConfiguration] = {
      helper.validateMethodConfiguration(workspaceNamespace, workspaceName, configNamespace, configName)
  }

  /**
   * Retrieve user permissions for the workspace and the workspace&#39;s method references
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param reportInput Users and/or configs on which to report, both optional 
   * @return PermissionReport
   */
  def workspacePermissionReport(workspaceNamespace: String, workspaceName: String, reportInput: PermissionReportRequest): Option[PermissionReport] = {
    val await = Try(Await.result(workspacePermissionReportAsync(workspaceNamespace, workspaceName, reportInput), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve user permissions for the workspace and the workspace&#39;s method references asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param reportInput Users and/or configs on which to report, both optional 
   * @return Future(PermissionReport)
   */
  def workspacePermissionReportAsync(workspaceNamespace: String, workspaceName: String, reportInput: PermissionReportRequest): Future[PermissionReport] = {
      helper.workspacePermissionReport(workspaceNamespace, workspaceName, reportInput)
  }

}

class MethodConfigurationsApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def copyFromMethodRepo(workspaceNamespace: String,
    workspaceName: String,
    configToCopy: CopyConfigurationIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[CopyConfigurationIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/copyFromMethodRepo")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->copyFromMethodRepo")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->copyFromMethodRepo")

    if (configToCopy == null) throw new Exception("Missing required parameter 'configToCopy' when calling MethodConfigurationsApi->copyFromMethodRepo")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(configToCopy))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def copyToMethodRepo(workspaceNamespace: String,
    workspaceName: String,
    configToCopy: PublishConfigurationIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[PublishConfigurationIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/copyToMethodRepo")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->copyToMethodRepo")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->copyToMethodRepo")

    if (configToCopy == null) throw new Exception("Missing required parameter 'configToCopy' when calling MethodConfigurationsApi->copyToMethodRepo")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(configToCopy))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    configNamespace: String,
    configName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/{configNamespace}/{configName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "configNamespace" + "\\}", configNamespace.toString)
      replaceAll("\\{" + "configName" + "\\}", configName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->deleteWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->deleteWorkspaceMethodConfig")

    if (configNamespace == null) throw new Exception("Missing required parameter 'configNamespace' when calling MethodConfigurationsApi->deleteWorkspaceMethodConfig")

    if (configName == null) throw new Exception("Missing required parameter 'configName' when calling MethodConfigurationsApi->deleteWorkspaceMethodConfig")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    configNamespace: String,
    configName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/{configNamespace}/{configName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "configNamespace" + "\\}", configNamespace.toString)
      replaceAll("\\{" + "configName" + "\\}", configName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->getWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->getWorkspaceMethodConfig")

    if (configNamespace == null) throw new Exception("Missing required parameter 'configNamespace' when calling MethodConfigurationsApi->getWorkspaceMethodConfig")

    if (configName == null) throw new Exception("Missing required parameter 'configName' when calling MethodConfigurationsApi->getWorkspaceMethodConfig")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def importStatus()(implicit reader: ClientResponseReader[UserImportPermission]): Future[UserImportPermission] = {
    // create path and map variables
    val path = (addFmt("/api/profile/importstatus"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listWorkspaceMethodConfigs(workspaceNamespace: String,
    workspaceName: String,
    allRepos: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->listWorkspaceMethodConfigs")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->listWorkspaceMethodConfigs")

    allRepos match {
      case Some(param) => queryParams += "allRepos" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def overwriteWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    configNamespace: String,
    configName: String,
    body: ConfigurationIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[ConfigurationIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/{configNamespace}/{configName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "configNamespace" + "\\}", configNamespace.toString)
      replaceAll("\\{" + "configName" + "\\}", configName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->overwriteWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->overwriteWorkspaceMethodConfig")

    if (configNamespace == null) throw new Exception("Missing required parameter 'configNamespace' when calling MethodConfigurationsApi->overwriteWorkspaceMethodConfig")

    if (configName == null) throw new Exception("Missing required parameter 'configName' when calling MethodConfigurationsApi->overwriteWorkspaceMethodConfig")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling MethodConfigurationsApi->overwriteWorkspaceMethodConfig")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    methodConfigJson: NewMethodConfigIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[NewMethodConfigIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->postWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->postWorkspaceMethodConfig")

    if (methodConfigJson == null) throw new Exception("Missing required parameter 'methodConfigJson' when calling MethodConfigurationsApi->postWorkspaceMethodConfig")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(methodConfigJson))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def renameWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    configNamespace: String,
    configName: String,
    rename: MethodConfigRename)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[MethodConfigRename]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/{configNamespace}/{configName}/rename")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "configNamespace" + "\\}", configNamespace.toString)
      replaceAll("\\{" + "configName" + "\\}", configName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->renameWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->renameWorkspaceMethodConfig")

    if (configNamespace == null) throw new Exception("Missing required parameter 'configNamespace' when calling MethodConfigurationsApi->renameWorkspaceMethodConfig")

    if (configName == null) throw new Exception("Missing required parameter 'configName' when calling MethodConfigurationsApi->renameWorkspaceMethodConfig")

    if (rename == null) throw new Exception("Missing required parameter 'rename' when calling MethodConfigurationsApi->renameWorkspaceMethodConfig")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(rename))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    configNamespace: String,
    configName: String,
    body: ConfigurationIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[ConfigurationIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/{configNamespace}/{configName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "configNamespace" + "\\}", configNamespace.toString)
      replaceAll("\\{" + "configName" + "\\}", configName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->updateWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->updateWorkspaceMethodConfig")

    if (configNamespace == null) throw new Exception("Missing required parameter 'configNamespace' when calling MethodConfigurationsApi->updateWorkspaceMethodConfig")

    if (configName == null) throw new Exception("Missing required parameter 'configName' when calling MethodConfigurationsApi->updateWorkspaceMethodConfig")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling MethodConfigurationsApi->updateWorkspaceMethodConfig")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(body))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def validateMethodConfiguration(workspaceNamespace: String,
    workspaceName: String,
    configNamespace: String,
    configName: String)(implicit reader: ClientResponseReader[ValidatedMethodConfiguration]): Future[ValidatedMethodConfiguration] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/method_configs/{configNamespace}/{configName}/validate")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString)
      replaceAll("\\{" + "configNamespace" + "\\}", configNamespace.toString)
      replaceAll("\\{" + "configName" + "\\}", configName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->validateMethodConfiguration")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->validateMethodConfiguration")

    if (configNamespace == null) throw new Exception("Missing required parameter 'configNamespace' when calling MethodConfigurationsApi->validateMethodConfiguration")

    if (configName == null) throw new Exception("Missing required parameter 'configName' when calling MethodConfigurationsApi->validateMethodConfiguration")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def workspacePermissionReport(workspaceNamespace: String,
    workspaceName: String,
    reportInput: PermissionReportRequest)(implicit reader: ClientResponseReader[PermissionReport], writer: RequestWriter[PermissionReportRequest]): Future[PermissionReport] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/permissionReport")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling MethodConfigurationsApi->workspacePermissionReport")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling MethodConfigurationsApi->workspacePermissionReport")

    if (reportInput == null) throw new Exception("Missing required parameter 'reportInput' when calling MethodConfigurationsApi->workspacePermissionReport")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(reportInput))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
