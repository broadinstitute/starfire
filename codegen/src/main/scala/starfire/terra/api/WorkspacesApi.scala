/**
 * FireCloud
 * Genome analysis execution service. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package starfire.terra.api

import java.text.SimpleDateFormat

import starfire.terra.model.AttributeUpdateOperation
import starfire.terra.model.ErrorReport
import java.io.File
import starfire.terra.model.ManagedGroupAccessInstructions
import starfire.terra.model.NewMethodConfigIngest
import starfire.terra.model.PermissionReport
import starfire.terra.model.PermissionReportRequest
import starfire.terra.model.StringArray
import starfire.terra.model.WorkspaceACL
import starfire.terra.model.WorkspaceACLUpdate
import starfire.terra.model.WorkspaceACLUpdateResponseList
import starfire.terra.model.WorkspaceBucketOptions
import starfire.terra.model.WorkspaceCatalog
import starfire.terra.model.WorkspaceCatalogUpdateResponseList
import starfire.terra.model.WorkspaceIngest
import starfire.terra.model.WorkspaceTag
import io.swagger.client.{ApiInvoker, ApiException}

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date
import java.util.TimeZone

import scala.collection.mutable.HashMap

import com.wordnik.swagger.client._
import scala.concurrent.Future
import collection.mutable

import java.net.URI

import com.wordnik.swagger.client.ClientResponseReaders.Json4sFormatsReader._
import com.wordnik.swagger.client.RequestWriters.Json4sFormatsWriter._

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent._
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import org.json4s._

class WorkspacesApi(
  val defBasePath: String = "https://localhost",
  defApiInvoker: ApiInvoker = ApiInvoker
) {
  private lazy val dateTimeFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  private val dateFormatter = {
    val formatter = new SimpleDateFormat("yyyy-MM-dd")
    formatter.setTimeZone(TimeZone.getTimeZone("UTC"))
    formatter
  }
  implicit val formats = new org.json4s.DefaultFormats {
    override def dateFormatter = dateTimeFormatter
  }
  implicit val stringReader: ClientResponseReader[String] = ClientResponseReaders.StringReader
  implicit val unitReader: ClientResponseReader[Unit] = ClientResponseReaders.UnitReader
  implicit val jvalueReader: ClientResponseReader[JValue] = ClientResponseReaders.JValueReader
  implicit val jsonReader: ClientResponseReader[Nothing] = JsonFormatsReader
  implicit val stringWriter: RequestWriter[String] = RequestWriters.StringWriter
  implicit val jsonWriter: RequestWriter[Nothing] = JsonFormatsWriter

  var basePath: String = defBasePath
  var apiInvoker: ApiInvoker = defApiInvoker

  def addHeader(key: String, value: String): mutable.HashMap[String, String] = {
    apiInvoker.defaultHeaders += key -> value
  }

  val config: SwaggerConfig = SwaggerConfig.forUrl(new URI(defBasePath))
  val client = new RestClient(config)
  val helper = new WorkspacesApiAsyncHelper(client, config)

  /**
   * TSV file containing workspace attributes (allows cookie-based authentication) 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return File
   */
  def browserDownloadAttributes(workspaceNamespace: String, workspaceName: String): Option[File] = {
    val await = Try(Await.result(browserDownloadAttributesAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * TSV file containing workspace attributes (allows cookie-based authentication)  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(File)
   */
  def browserDownloadAttributesAsync(workspaceNamespace: String, workspaceName: String): Future[File] = {
      helper.browserDownloadAttributes(workspaceNamespace, workspaceName)
  }

  /**
   * Sends notifications for change to workspace
   * 
   *
   * @param workspaceNamespace workspace namespace 
   * @param workspaceName workspace name 
   * @return void
   */
  def changedWorkspaceNotification(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(changedWorkspaceNotificationAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Sends notifications for change to workspace asynchronously
   * 
   *
   * @param workspaceNamespace workspace namespace 
   * @param workspaceName workspace name 
   * @return Future(void)
   */
  def changedWorkspaceNotificationAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.changedWorkspaceNotification(workspaceNamespace, workspaceName)
  }

  /**
   * Clone Workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param workspace Cloned workspace information 
   * @return void
   */
  def cloneWorkspace(workspaceNamespace: String, workspaceName: String, workspace: WorkspaceIngest) = {
    val await = Try(Await.result(cloneWorkspaceAsync(workspaceNamespace, workspaceName, workspace), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Clone Workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param workspace Cloned workspace information 
   * @return Future(void)
   */
  def cloneWorkspaceAsync(workspaceNamespace: String, workspaceName: String, workspace: WorkspaceIngest) = {
      helper.cloneWorkspace(workspaceNamespace, workspaceName, workspace)
  }

  /**
   * Create workspace
   * 
   *
   * @param workspace New workspace information 
   * @return void
   */
  def createWorkspace(workspace: WorkspaceIngest) = {
    val await = Try(Await.result(createWorkspaceAsync(workspace), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create workspace asynchronously
   * 
   *
   * @param workspace New workspace information 
   * @return Future(void)
   */
  def createWorkspaceAsync(workspace: WorkspaceIngest) = {
      helper.createWorkspace(workspace)
  }

  /**
   * Delete workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def deleteWorkspace(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(deleteWorkspaceAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Delete workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def deleteWorkspaceAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.deleteWorkspace(workspaceNamespace, workspaceName)
  }

  /**
   * Remove the user-supplied tags from the workspace. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param tags List of tags. 
   * @return StringArray
   */
  def deleteWorkspaceTags(workspaceNamespace: String, workspaceName: String, tags: StringArray): Option[StringArray] = {
    val await = Try(Await.result(deleteWorkspaceTagsAsync(workspaceNamespace, workspaceName, tags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Remove the user-supplied tags from the workspace.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param tags List of tags. 
   * @return Future(StringArray)
   */
  def deleteWorkspaceTagsAsync(workspaceNamespace: String, workspaceName: String, tags: StringArray): Future[StringArray] = {
      helper.deleteWorkspaceTags(workspaceNamespace, workspaceName, tags)
  }

  /**
   * TSV file containing workspace attributes 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return File
   */
  def exportAttributesTSV(workspaceNamespace: String, workspaceName: String): Option[File] = {
    val await = Try(Await.result(exportAttributesTSVAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * TSV file containing workspace attributes  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(File)
   */
  def exportAttributesTSVAsync(workspaceNamespace: String, workspaceName: String): Future[File] = {
      helper.exportAttributesTSV(workspaceNamespace, workspaceName)
  }

  /**
   * Get bucket usage
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def getBucketUsage(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(getBucketUsageAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get bucket usage asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def getBucketUsageAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.getBucketUsage(workspaceNamespace, workspaceName)
  }

  /**
   * Get workspace catalog permission
   * Get catalog permissions for a workspace
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return List[WorkspaceCatalog]
   */
  def getCatalog(workspaceNamespace: String, workspaceName: String): Option[List[WorkspaceCatalog]] = {
    val await = Try(Await.result(getCatalogAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get workspace catalog permission asynchronously
   * Get catalog permissions for a workspace
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(List[WorkspaceCatalog])
   */
  def getCatalogAsync(workspaceNamespace: String, workspaceName: String): Future[List[WorkspaceCatalog]] = {
      helper.getCatalog(workspaceNamespace, workspaceName)
  }

  /**
   * Calculate an estimate of the monthly storage cost for the workspace bucket
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def getStorageCostEstimate(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(getStorageCostEstimateAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Calculate an estimate of the monthly storage cost for the workspace bucket asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def getStorageCostEstimateAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.getStorageCostEstimate(workspaceNamespace, workspaceName)
  }

  /**
   * Get all tags used in FireCloud (for autocomplete) 
   * list of all tags used in FireCloud and their associated frequencies
   *
   * @param q Query string (optional)
   * @return List[WorkspaceTag]
   */
  def getTags(q: Option[String] = None): Option[List[WorkspaceTag]] = {
    val await = Try(Await.result(getTagsAsync(q), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get all tags used in FireCloud (for autocomplete)  asynchronously
   * list of all tags used in FireCloud and their associated frequencies
   *
   * @param q Query string (optional)
   * @return Future(List[WorkspaceTag])
   */
  def getTagsAsync(q: Option[String] = None): Future[List[WorkspaceTag]] = {
      helper.getTags(q)
  }

  /**
   * Get workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param fields When specified, include only these keys in the response payload and exclude other keys. Accepts a comma-delimited list of values. To include a nested key, specify the key&#39;s path using a dot delimiter; for example, to include {\&quot;workspace\&quot;: {\&quot;attributes\&quot;: {}}}, specify \&quot;workspace.attributes\&quot;. Legal values are any first-level key in the response, any first-level key inside the {\&quot;workspace\&quot;: {}} object, and any first-level key inside the {\&quot;workspace\&quot;: {\&quot;attributes\&quot;: {}}} object. If omitted, will return the full response payload.  (optional)
   * @return void
   */
  def getWorkspace(workspaceNamespace: String, workspaceName: String, fields: Option[List[String]] = None) = {
    val await = Try(Await.result(getWorkspaceAsync(workspaceNamespace, workspaceName, fields), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param fields When specified, include only these keys in the response payload and exclude other keys. Accepts a comma-delimited list of values. To include a nested key, specify the key&#39;s path using a dot delimiter; for example, to include {\&quot;workspace\&quot;: {\&quot;attributes\&quot;: {}}}, specify \&quot;workspace.attributes\&quot;. Legal values are any first-level key in the response, any first-level key inside the {\&quot;workspace\&quot;: {}} object, and any first-level key inside the {\&quot;workspace\&quot;: {\&quot;attributes\&quot;: {}}} object. If omitted, will return the full response payload.  (optional)
   * @return Future(void)
   */
  def getWorkspaceAsync(workspaceNamespace: String, workspaceName: String, fields: Option[List[String]] = None) = {
      helper.getWorkspace(workspaceNamespace, workspaceName, fields)
  }

  /**
   * Get workspace access instructions (if any)
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return List[ManagedGroupAccessInstructions]
   */
  def getWorkspaceAccessInstructions(workspaceNamespace: String, workspaceName: String): Option[List[ManagedGroupAccessInstructions]] = {
    val await = Try(Await.result(getWorkspaceAccessInstructionsAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get workspace access instructions (if any) asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(List[ManagedGroupAccessInstructions])
   */
  def getWorkspaceAccessInstructionsAsync(workspaceNamespace: String, workspaceName: String): Future[List[ManagedGroupAccessInstructions]] = {
      helper.getWorkspaceAccessInstructions(workspaceNamespace, workspaceName)
  }

  /**
   * Get workspace ACL
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return WorkspaceACL
   */
  def getWorkspaceAcl(workspaceNamespace: String, workspaceName: String): Option[WorkspaceACL] = {
    val await = Try(Await.result(getWorkspaceAclAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get workspace ACL asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(WorkspaceACL)
   */
  def getWorkspaceAclAsync(workspaceNamespace: String, workspaceName: String): Future[WorkspaceACL] = {
      helper.getWorkspaceAcl(workspaceNamespace, workspaceName)
  }

  /**
   * Get metadata about the workspace bucket
   * Returns metadata about the workspace bucket.
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return WorkspaceBucketOptions
   */
  def getWorkspaceBucketOptions(workspaceNamespace: String, workspaceName: String): Option[WorkspaceBucketOptions] = {
    val await = Try(Await.result(getWorkspaceBucketOptionsAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get metadata about the workspace bucket asynchronously
   * Returns metadata about the workspace bucket.
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(WorkspaceBucketOptions)
   */
  def getWorkspaceBucketOptionsAsync(workspaceNamespace: String, workspaceName: String): Future[WorkspaceBucketOptions] = {
      helper.getWorkspaceBucketOptions(workspaceNamespace, workspaceName)
  }

  /**
   * Get the tags for this workspace. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return StringArray
   */
  def getWorkspaceTags(workspaceNamespace: String, workspaceName: String): Option[StringArray] = {
    val await = Try(Await.result(getWorkspaceTagsAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Get the tags for this workspace.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(StringArray)
   */
  def getWorkspaceTagsAsync(workspaceNamespace: String, workspaceName: String): Future[StringArray] = {
      helper.getWorkspaceTags(workspaceNamespace, workspaceName)
  }

  /**
   * Import workspace attributes from a tsv file
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param attributes A valid TSV import file 
   * @return void
   */
  def importAttributesTSV(workspaceNamespace: String, workspaceName: String, attributes: File) = {
    val await = Try(Await.result(importAttributesTSVAsync(workspaceNamespace, workspaceName, attributes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Import workspace attributes from a tsv file asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param attributes A valid TSV import file 
   * @return Future(void)
   */
  def importAttributesTSVAsync(workspaceNamespace: String, workspaceName: String, attributes: File) = {
      helper.importAttributesTSV(workspaceNamespace, workspaceName, attributes)
  }

  /**
   * List method configurations in a workspace
   * List method configurations in a workspace. By default, only Agora method configs are returned. To return configs for all repos, specify &#x60;allRepos&#x60; to be &#x60;true&#x60;.  #### Expanded discussion on the methodRepoMethod field  This endpoint returns method references to Agora in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; and for Dockstore in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot;,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; If you are only working with Agora methods, the fields &#x60;\&quot;sourceRepo\&quot;&#x60; and &#x60;\&quot;methodUri\&quot;&#x60; can be considered informational and do not need to be round-tripped (see the corresponding &#x60;POST /api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs&#x60; for more details). 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param allRepos Configs for all repos, not just Agora (optional, default to false)
   * @return void
   */
  def listWorkspaceMethodConfigs(workspaceNamespace: String, workspaceName: String, allRepos: Option[Boolean] = Option(false)) = {
    val await = Try(Await.result(listWorkspaceMethodConfigsAsync(workspaceNamespace, workspaceName, allRepos), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * List method configurations in a workspace asynchronously
   * List method configurations in a workspace. By default, only Agora method configs are returned. To return configs for all repos, specify &#x60;allRepos&#x60; to be &#x60;true&#x60;.  #### Expanded discussion on the methodRepoMethod field  This endpoint returns method references to Agora in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; and for Dockstore in the format &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot;,   \&quot;sourceRepo\&quot;: \&quot;agora\&quot;,   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; If you are only working with Agora methods, the fields &#x60;\&quot;sourceRepo\&quot;&#x60; and &#x60;\&quot;methodUri\&quot;&#x60; can be considered informational and do not need to be round-tripped (see the corresponding &#x60;POST /api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs&#x60; for more details). 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param allRepos Configs for all repos, not just Agora (optional, default to false)
   * @return Future(void)
   */
  def listWorkspaceMethodConfigsAsync(workspaceNamespace: String, workspaceName: String, allRepos: Option[Boolean] = Option(false)) = {
      helper.listWorkspaceMethodConfigs(workspaceNamespace, workspaceName, allRepos)
  }

  /**
   * Lists workspaces. 
   * 
   *
   * @return void
   */
  def listWorkspaces() = {
    val await = Try(Await.result(listWorkspacesAsync(), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Lists workspaces.  asynchronously
   * 
   *
   * @return Future(void)
   */
  def listWorkspacesAsync() = {
      helper.listWorkspaces()
  }

  /**
   * Lock Workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def lockWorkspace(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(lockWorkspaceAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Lock Workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def lockWorkspaceAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.lockWorkspace(workspaceNamespace, workspaceName)
  }

  /**
   * Add tags to the workspace without modifying pre-existing tags. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param tags List of tags. 
   * @return StringArray
   */
  def patchWorkspaceTags(workspaceNamespace: String, workspaceName: String, tags: StringArray): Option[StringArray] = {
    val await = Try(Await.result(patchWorkspaceTagsAsync(workspaceNamespace, workspaceName, tags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Add tags to the workspace without modifying pre-existing tags.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param tags List of tags. 
   * @return Future(StringArray)
   */
  def patchWorkspaceTagsAsync(workspaceNamespace: String, workspaceName: String, tags: StringArray): Future[StringArray] = {
      helper.patchWorkspaceTags(workspaceNamespace, workspaceName, tags)
  }

  /**
   * Create a Method Configuration in a workspace
   * Create method configurations. #### Expanded discussion on the methodRepoMethod field To create a method config for an Agora method, &#x60;\&quot;sourceRepo\&quot;: \&quot;agora\&quot;&#x60; is optional; the following is sufficient: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1 } &#x60;&#x60;&#x60; To create a method config for a Dockstore method, &#x60;\&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;&#x60; is required: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;,   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot; } &#x60;&#x60;&#x60; You may also use the URI on its own to create a config referencing any supported repo (currently Agora and Dockstore): &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; The system is specified to check for a URI first before falling back to the legacy fields. Unsupported repos will return a 400 Bad Request. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param methodConfigJson Method Configuration contents 
   * @return void
   */
  def postWorkspaceMethodConfig(workspaceNamespace: String, workspaceName: String, methodConfigJson: NewMethodConfigIngest) = {
    val await = Try(Await.result(postWorkspaceMethodConfigAsync(workspaceNamespace, workspaceName, methodConfigJson), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Create a Method Configuration in a workspace asynchronously
   * Create method configurations. #### Expanded discussion on the methodRepoMethod field To create a method config for an Agora method, &#x60;\&quot;sourceRepo\&quot;: \&quot;agora\&quot;&#x60; is optional; the following is sufficient: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodNamespace\&quot;: \&quot;namespace\&quot;,   \&quot;methodName\&quot;: \&quot;name\&quot;,   \&quot;methodVersion\&quot;: 1 } &#x60;&#x60;&#x60; To create a method config for a Dockstore method, &#x60;\&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;&#x60; is required: &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;sourceRepo\&quot;: \&quot;dockstore\&quot;,   \&quot;methodPath\&quot;: \&quot;path\&quot;,   \&quot;methodVersion\&quot;: \&quot;version\&quot; } &#x60;&#x60;&#x60; You may also use the URI on its own to create a config referencing any supported repo (currently Agora and Dockstore): &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;agora://namespace/name/1\&quot; } &#x60;&#x60;&#x60; &#x60;&#x60;&#x60; \&quot;methodRepoMethod\&quot;: {   \&quot;methodUri\&quot;: \&quot;dockstore://path/version\&quot; } &#x60;&#x60;&#x60; The system is specified to check for a URI first before falling back to the legacy fields. Unsupported repos will return a 400 Bad Request. 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param methodConfigJson Method Configuration contents 
   * @return Future(void)
   */
  def postWorkspaceMethodConfigAsync(workspaceNamespace: String, workspaceName: String, methodConfigJson: NewMethodConfigIngest) = {
      helper.postWorkspaceMethodConfig(workspaceNamespace, workspaceName, methodConfigJson)
  }

  /**
   * Replace all tags for this workspace with the user input. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param tags List of tags. 
   * @return StringArray
   */
  def putWorkspaceTags(workspaceNamespace: String, workspaceName: String, tags: StringArray): Option[StringArray] = {
    val await = Try(Await.result(putWorkspaceTagsAsync(workspaceNamespace, workspaceName, tags), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Replace all tags for this workspace with the user input.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param tags List of tags. 
   * @return Future(StringArray)
   */
  def putWorkspaceTagsAsync(workspaceNamespace: String, workspaceName: String, tags: StringArray): Future[StringArray] = {
      helper.putWorkspaceTags(workspaceNamespace, workspaceName, tags)
  }

  /**
   * Read workspace bucket
   * Read a workspace bucket
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def readBucket(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(readBucketAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Read workspace bucket asynchronously
   * Read a workspace bucket
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def readBucketAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.readBucket(workspaceNamespace, workspaceName)
  }

  /**
   * Set attributes on a workspace. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param newAttributes New attribute values, as Map[String, Attribute]. WARNING! This should not be used to change library metadata (republish will not happen). Use UpdateAttributes in the library section 
   * @return void
   */
  def setAttributes(workspaceNamespace: String, workspaceName: String, newAttributes: Any) = {
    val await = Try(Await.result(setAttributesAsync(workspaceNamespace, workspaceName, newAttributes), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Set attributes on a workspace.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param newAttributes New attribute values, as Map[String, Attribute]. WARNING! This should not be used to change library metadata (republish will not happen). Use UpdateAttributes in the library section 
   * @return Future(void)
   */
  def setAttributesAsync(workspaceNamespace: String, workspaceName: String, newAttributes: Any) = {
      helper.setAttributes(workspaceNamespace, workspaceName, newAttributes)
  }

  /**
   * Unlock Workspace
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return void
   */
  def unlockWorkspace(workspaceNamespace: String, workspaceName: String) = {
    val await = Try(Await.result(unlockWorkspaceAsync(workspaceNamespace, workspaceName), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Unlock Workspace asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @return Future(void)
   */
  def unlockWorkspaceAsync(workspaceNamespace: String, workspaceName: String) = {
      helper.unlockWorkspace(workspaceNamespace, workspaceName)
  }

  /**
   * Modify attributes on a workspace. 
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param workspaceUpdateJson Attribute operations. WARNING! This should not be used to change library metadata (republish will not happen). Use UpdateAttributes in the library section. 
   * @return void
   */
  def updateAttributes(workspaceNamespace: String, workspaceName: String, workspaceUpdateJson: List[AttributeUpdateOperation]) = {
    val await = Try(Await.result(updateAttributesAsync(workspaceNamespace, workspaceName, workspaceUpdateJson), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Modify attributes on a workspace.  asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param workspaceUpdateJson Attribute operations. WARNING! This should not be used to change library metadata (republish will not happen). Use UpdateAttributes in the library section. 
   * @return Future(void)
   */
  def updateAttributesAsync(workspaceNamespace: String, workspaceName: String, workspaceUpdateJson: List[AttributeUpdateOperation]) = {
      helper.updateAttributes(workspaceNamespace, workspaceName, workspaceUpdateJson)
  }

  /**
   * Update catalog permission
   * Set catalog permisisons for a workspace
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param catalogUpdates Series of Catalog updates for workspace 
   * @return WorkspaceCatalogUpdateResponseList
   */
  def updateCatalog(workspaceNamespace: String, workspaceName: String, catalogUpdates: List[WorkspaceCatalog]): Option[WorkspaceCatalogUpdateResponseList] = {
    val await = Try(Await.result(updateCatalogAsync(workspaceNamespace, workspaceName, catalogUpdates), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update catalog permission asynchronously
   * Set catalog permisisons for a workspace
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param catalogUpdates Series of Catalog updates for workspace 
   * @return Future(WorkspaceCatalogUpdateResponseList)
   */
  def updateCatalogAsync(workspaceNamespace: String, workspaceName: String, catalogUpdates: List[WorkspaceCatalog]): Future[WorkspaceCatalogUpdateResponseList] = {
      helper.updateCatalog(workspaceNamespace, workspaceName, catalogUpdates)
  }

  /**
   * Update workspace ACL
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param inviteUsersNotFound true to invite unregistered users, false to ignore 
   * @param aclUpdates Series of ACL updates for workspace 
   * @return WorkspaceACLUpdateResponseList
   */
  def updateWorkspaceACL(workspaceNamespace: String, workspaceName: String, inviteUsersNotFound: Boolean = false, aclUpdates: List[WorkspaceACLUpdate]): Option[WorkspaceACLUpdateResponseList] = {
    val await = Try(Await.result(updateWorkspaceACLAsync(workspaceNamespace, workspaceName, inviteUsersNotFound, aclUpdates), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Update workspace ACL asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param inviteUsersNotFound true to invite unregistered users, false to ignore 
   * @param aclUpdates Series of ACL updates for workspace 
   * @return Future(WorkspaceACLUpdateResponseList)
   */
  def updateWorkspaceACLAsync(workspaceNamespace: String, workspaceName: String, inviteUsersNotFound: Boolean = false, aclUpdates: List[WorkspaceACLUpdate]): Future[WorkspaceACLUpdateResponseList] = {
      helper.updateWorkspaceACL(workspaceNamespace, workspaceName, inviteUsersNotFound, aclUpdates)
  }

  /**
   * Retrieve user permissions for the workspace and the workspace&#39;s method references
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param reportInput Users and/or configs on which to report, both optional 
   * @return PermissionReport
   */
  def workspacePermissionReport(workspaceNamespace: String, workspaceName: String, reportInput: PermissionReportRequest): Option[PermissionReport] = {
    val await = Try(Await.result(workspacePermissionReportAsync(workspaceNamespace, workspaceName, reportInput), Duration.Inf))
    await match {
      case Success(i) => Some(await.get)
      case Failure(t) => None
    }
  }

  /**
   * Retrieve user permissions for the workspace and the workspace&#39;s method references asynchronously
   * 
   *
   * @param workspaceNamespace Workspace Namespace 
   * @param workspaceName Workspace Name 
   * @param reportInput Users and/or configs on which to report, both optional 
   * @return Future(PermissionReport)
   */
  def workspacePermissionReportAsync(workspaceNamespace: String, workspaceName: String, reportInput: PermissionReportRequest): Future[PermissionReport] = {
      helper.workspacePermissionReport(workspaceNamespace, workspaceName, reportInput)
  }

}

class WorkspacesApiAsyncHelper(client: TransportClient, config: SwaggerConfig) extends ApiClient(client, config) {

  def browserDownloadAttributes(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/cookie-authed/workspaces/{workspaceNamespace}/{workspaceName}/exportAttributesTSV")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->browserDownloadAttributes")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->browserDownloadAttributes")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def changedWorkspaceNotification(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/sendChangeNotification")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->changedWorkspaceNotification")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->changedWorkspaceNotification")


    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def cloneWorkspace(workspaceNamespace: String,
    workspaceName: String,
    workspace: WorkspaceIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[WorkspaceIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/clone")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->cloneWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->cloneWorkspace")

    if (workspace == null) throw new Exception("Missing required parameter 'workspace' when calling WorkspacesApi->cloneWorkspace")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(workspace))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def createWorkspace(workspace: WorkspaceIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[WorkspaceIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspace == null) throw new Exception("Missing required parameter 'workspace' when calling WorkspacesApi->createWorkspace")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(workspace))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteWorkspace(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->deleteWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->deleteWorkspace")


    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def deleteWorkspaceTags(workspaceNamespace: String,
    workspaceName: String,
    tags: StringArray)(implicit reader: ClientResponseReader[StringArray], writer: RequestWriter[StringArray]): Future[StringArray] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/tags")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->deleteWorkspaceTags")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->deleteWorkspaceTags")

    if (tags == null) throw new Exception("Missing required parameter 'tags' when calling WorkspacesApi->deleteWorkspaceTags")

    val resFuture = client.submit("DELETE", path, queryParams.toMap, headerParams.toMap, writer.write(tags))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def exportAttributesTSV(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[File]): Future[File] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/exportAttributesTSV")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->exportAttributesTSV")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->exportAttributesTSV")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getBucketUsage(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/bucketUsage")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getBucketUsage")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getBucketUsage")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getCatalog(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[List[WorkspaceCatalog]]): Future[List[WorkspaceCatalog]] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/catalog")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getCatalog")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getCatalog")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getStorageCostEstimate(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/storageCostEstimate")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getStorageCostEstimate")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getStorageCostEstimate")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getTags(q: Option[String] = None
    )(implicit reader: ClientResponseReader[List[WorkspaceTag]]): Future[List[WorkspaceTag]] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/tags"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    q match {
      case Some(param) => queryParams += "q" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getWorkspace(workspaceNamespace: String,
    workspaceName: String,
    fields: Option[List[String]] = None
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getWorkspace")

    fields match {
      case Some(param) => queryParams += "fields" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getWorkspaceAccessInstructions(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[List[ManagedGroupAccessInstructions]]): Future[List[ManagedGroupAccessInstructions]] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/accessInstructions")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getWorkspaceAccessInstructions")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getWorkspaceAccessInstructions")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getWorkspaceAcl(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[WorkspaceACL]): Future[WorkspaceACL] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/acl")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getWorkspaceAcl")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getWorkspaceAcl")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getWorkspaceBucketOptions(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[WorkspaceBucketOptions]): Future[WorkspaceBucketOptions] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/bucketOptions")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getWorkspaceBucketOptions")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getWorkspaceBucketOptions")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def getWorkspaceTags(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[StringArray]): Future[StringArray] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/tags")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->getWorkspaceTags")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->getWorkspaceTags")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def importAttributesTSV(workspaceNamespace: String,
    workspaceName: String,
    attributes: File)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/importAttributesTSV")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->importAttributesTSV")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->importAttributesTSV")

    if (attributes == null) throw new Exception("Missing required parameter 'attributes' when calling WorkspacesApi->importAttributesTSV")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listWorkspaceMethodConfigs(workspaceNamespace: String,
    workspaceName: String,
    allRepos: Option[Boolean] = Option(false)
    )(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->listWorkspaceMethodConfigs")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->listWorkspaceMethodConfigs")

    allRepos match {
      case Some(param) => queryParams += "allRepos" -> param.toString
      case _ => queryParams
    }

    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def listWorkspaces()(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces"))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def lockWorkspace(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/lock")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->lockWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->lockWorkspace")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def patchWorkspaceTags(workspaceNamespace: String,
    workspaceName: String,
    tags: StringArray)(implicit reader: ClientResponseReader[StringArray], writer: RequestWriter[StringArray]): Future[StringArray] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/tags")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->patchWorkspaceTags")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->patchWorkspaceTags")

    if (tags == null) throw new Exception("Missing required parameter 'tags' when calling WorkspacesApi->patchWorkspaceTags")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(tags))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def postWorkspaceMethodConfig(workspaceNamespace: String,
    workspaceName: String,
    methodConfigJson: NewMethodConfigIngest)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[NewMethodConfigIngest]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/methodconfigs")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->postWorkspaceMethodConfig")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->postWorkspaceMethodConfig")

    if (methodConfigJson == null) throw new Exception("Missing required parameter 'methodConfigJson' when calling WorkspacesApi->postWorkspaceMethodConfig")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(methodConfigJson))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def putWorkspaceTags(workspaceNamespace: String,
    workspaceName: String,
    tags: StringArray)(implicit reader: ClientResponseReader[StringArray], writer: RequestWriter[StringArray]): Future[StringArray] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/tags")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->putWorkspaceTags")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->putWorkspaceTags")

    if (tags == null) throw new Exception("Missing required parameter 'tags' when calling WorkspacesApi->putWorkspaceTags")

    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, writer.write(tags))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def readBucket(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/checkBucketReadAccess")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->readBucket")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->readBucket")


    val resFuture = client.submit("GET", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def setAttributes(workspaceNamespace: String,
    workspaceName: String,
    newAttributes: Any)(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[Any]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/setAttributes")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->setAttributes")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->setAttributes")


    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(newAttributes))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def unlockWorkspace(workspaceNamespace: String,
    workspaceName: String)(implicit reader: ClientResponseReader[Unit]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/unlock")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->unlockWorkspace")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->unlockWorkspace")


    val resFuture = client.submit("PUT", path, queryParams.toMap, headerParams.toMap, "")
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateAttributes(workspaceNamespace: String,
    workspaceName: String,
    workspaceUpdateJson: List[AttributeUpdateOperation])(implicit reader: ClientResponseReader[Unit], writer: RequestWriter[List[AttributeUpdateOperation]]): Future[Unit] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/updateAttributes")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->updateAttributes")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->updateAttributes")

    if (workspaceUpdateJson == null) throw new Exception("Missing required parameter 'workspaceUpdateJson' when calling WorkspacesApi->updateAttributes")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(workspaceUpdateJson))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateCatalog(workspaceNamespace: String,
    workspaceName: String,
    catalogUpdates: List[WorkspaceCatalog])(implicit reader: ClientResponseReader[WorkspaceCatalogUpdateResponseList], writer: RequestWriter[List[WorkspaceCatalog]]): Future[WorkspaceCatalogUpdateResponseList] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/catalog")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->updateCatalog")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->updateCatalog")

    if (catalogUpdates == null) throw new Exception("Missing required parameter 'catalogUpdates' when calling WorkspacesApi->updateCatalog")

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(catalogUpdates))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def updateWorkspaceACL(workspaceNamespace: String,
    workspaceName: String,
    inviteUsersNotFound: Boolean = false,
    aclUpdates: List[WorkspaceACLUpdate])(implicit reader: ClientResponseReader[WorkspaceACLUpdateResponseList], writer: RequestWriter[List[WorkspaceACLUpdate]]): Future[WorkspaceACLUpdateResponseList] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/acl")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->updateWorkspaceACL")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->updateWorkspaceACL")

    if (aclUpdates == null) throw new Exception("Missing required parameter 'aclUpdates' when calling WorkspacesApi->updateWorkspaceACL")
    queryParams += "inviteUsersNotFound" -> inviteUsersNotFound.toString

    val resFuture = client.submit("PATCH", path, queryParams.toMap, headerParams.toMap, writer.write(aclUpdates))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }

  def workspacePermissionReport(workspaceNamespace: String,
    workspaceName: String,
    reportInput: PermissionReportRequest)(implicit reader: ClientResponseReader[PermissionReport], writer: RequestWriter[PermissionReportRequest]): Future[PermissionReport] = {
    // create path and map variables
    val path = (addFmt("/api/workspaces/{workspaceNamespace}/{workspaceName}/permissionReport")
      replaceAll("\\{" + "workspaceNamespace" + "\\}", workspaceNamespace.toString)
      replaceAll("\\{" + "workspaceName" + "\\}", workspaceName.toString))

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

    if (workspaceNamespace == null) throw new Exception("Missing required parameter 'workspaceNamespace' when calling WorkspacesApi->workspacePermissionReport")

    if (workspaceName == null) throw new Exception("Missing required parameter 'workspaceName' when calling WorkspacesApi->workspacePermissionReport")

    if (reportInput == null) throw new Exception("Missing required parameter 'reportInput' when calling WorkspacesApi->workspacePermissionReport")

    val resFuture = client.submit("POST", path, queryParams.toMap, headerParams.toMap, writer.write(reportInput))
    resFuture flatMap { resp =>
      process(reader.read(resp))
    }
  }


}
